<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<style>
	body {margin: 0; padding: 4px 8px 24px; background-color: #ffffff; overflow-y: scroll}
    h1 {margin: 5px 0 0 0; font-size: 18px; font-weight: normal; text-align: center}
	header {margin: -24px 0 5px 0; line-height: 24px}
	button {font: 12px sans-serif; cursor: pointer}
	p {margin: 5px 0 5px 0}
	a {color: #0366d6}
	#hl {position: absolute; display: none; overflow: hidden; white-space: nowrap; pointer-events: none; background-color: #ffffe0; outline: 1px solid #ffc000; height: 15px}
	#hl span {padding: 0 3px 0 3px}
	#status {overflow: hidden; white-space: nowrap}
	#match {overflow: hidden; white-space: nowrap; display: none; float: right; text-align: right}
	#reset {cursor: pointer}
	#canvas {width: 100%; height: 300px}

    .selectionPart {position: absolute; display: none; pointer-events: none; box-sizing: border-box;}
    .sel {background-color: #dada0040}
    .act {background-color: #00da0040}
    .dif {background-color: #00dada40}
    .top {border-top: .1px solid #000}
    .left {border-left: .1px solid #000}
    .bottom {border-bottom: .1px solid #000}
    .right {border-right: .1px solid #000}

    #info-tooltip {display: none; position: absolute; top: 100px; right: 32px; width: 204px; border: 1px solid #666666; background: #ffffe0; border-radius: 8px; padding: 4px}
    #heatmap-height-line, #heatmap-info { text-decoration: #0366d6 dashed underline; cursor: pointer; font-family: monospace}
    #heatmap-info {cursor: help}
    #heatmap-info:hover + #info-tooltip {display: block}

    .colortip {width: 100px; box-sizing: border-box; padding: 4px; background: linear-gradient(var(--c1), var(--c2))}


</style>
</head>
<body style='font: 12px Verdana, sans-serif'>


<div style="display: flex">
    <div style="width: 20px; margin-right: 2px; float: left; writing-mode: vertical-rl; transform: scale(-1); text-align: center; user-select: none"><pre id="heatmap-height-line"> 1 sec : 20 ms </pre></div>

    <div id='heatmap-canvas-container' style="width: 100%; position: relative" autofocus>
        <div id='heatmap-canvas-wrapper' style='overflow: hidden; width: 100%'>
            <canvas id='heatmap-canvas' style='height: 314px'></canvas>
        </div>

        <div id='middleActive' class='selectionPart top bottom act'><span></span></div>
        <div id='leftActive' class='selectionPart top left bottom act'><span></span></div>
        <div id='rightActive' class='selectionPart top right bottom act'><span></span></div>
        <div id='leftMiddleActive' class='selectionPart right'><span></span></div>
        <div id='rightMiddleActive' class='selectionPart left'><span></span></div>

        <div id='middleSelection' class='selectionPart top bottom sel'><span></span></div>
        <div id='leftSelection' class='selectionPart top left bottom sel'><span></span></div>
        <div id='rightSelection' class='selectionPart top right bottom sel'><span></span></div>
        <div id='leftMiddleSelection' class='selectionPart right'><span></span></div>
        <div id='rightMiddleSelection' class='selectionPart left'><span></span></div>

        <div id='middleDiff' class='selectionPart top bottom dif'><span></span></div>
        <div id='leftDiff' class='selectionPart top left bottom dif'><span></span></div>
        <div id='rightDiff' class='selectionPart top right bottom dif'><span></span></div>
        <div id='leftMiddleDiff' class='selectionPart right'><span></span></div>
        <div id='rightMiddleDiff' class='selectionPart left'><span></span></div>
    </div>

    <div id="heatmap-info" style="width: 20px; margin-right: 2px; writing-mode: vertical-rl; text-align: center; user-select: none">
        <pre> Info </pre>
    </div>
    <div id="info-tooltip">
        <div style="float:left">
            <div style="padding: 4px;">Frame types:</div>
            <div class="colortip" style="--c1:#b2e1b2;--c2:#c6f5c6">Interpreted</div>
            <div class="colortip" style="--c1:#50e150;--c2:#6eff6e">JIT-Compiled</div>
            <div class="colortip" style="--c1:#50cccc;--c2:#6eeaea">Inlined</div>
            <div class="colortip" style="--c1:#e15a5a;--c2:#ff8282">Native</div>
            <div class="colortip" style="--c1:#c8c83c;--c2:#e6e646">C++</div>
            <div class="colortip" style="--c1:#e17d00;--c2:#ff9b00">Kernel</div>
            <div class="colortip" style="--c1:#cce880;--c2:#e0fc94">C1-Compiled</div>
        </div>
        <div style="float:left; margin-left: 4px">
            <div style="padding: 4px;">Special colors:</div>
            <div class="colortip" style="--c1:#ee00ee;--c2:#ee00ee">Matches regexp</div>
            <div class="colortip" style="--c1:#baa551;--c2:#baa551">New frames</div>
            <div class="colortip" style="--c1:#f0f0c0;--c2:#f0f0c0">Same frames</div>
            <div class="colortip" style="--c1:#99aaff;--c2:#99aaff">Less frames</div>
            <div class="colortip" style="--c1:#ffaa99;--c2:#ffaa99">More frames</div>
        </div>
        <div style="float:left; margin-top: 4px; width: 100%; border: 1px solid #666666; border-radius: 2px; padding: 2px; box-sizing: border-box;">
            Shift + Click - Select range<br>
            Ctrl + Click - Compare<br>
            Ctrl + F - Search<br>
        </div>
    </div>
</div>
<div id="executionsHeatmap" style="display:none">BIwQAQz@tBaDcEwG{GwKu|AGSHX@YP@QIHP@@IQHAAI@HGPPGIGHII`QP@G?QQH@GIPHOOHGPQG@HIG?P@O?HHPIHOG@@G?PP@@@?OHHGHOH@GGIO@HAG?@HA@P@PIGIHHAAHAQHAQ@HIG?HHIO?HIGHP?QG@GAIOQPG@H?HPAGP@GQHH@AP?Q@PPHHQPGG@HGIGPHIPHBPIOP@HGHGAG@@@@HHGHIHHGP@A?GHIH@G@@G?HOO@P@IPIOHHH@GIGHGH?GHAOHHH@IQAQ@A@GHH@HGQHAAIGP@IH?PPA?IQG@GHHP@A@@@Q@HG@GIHGP@IPIHI?HHQIOO?POHHHG?AGI@P?OPGOHPPHHG?POGHGHHIR??GIG@G?HIGIGAGHPIH@H@HPPH?HQH@PHH@QG@GP@HOHHQGAG@H@HHAQHAHOG@HIH@OQH@HGHI@HGAHHGOHH@HAP?PHGP@A?PQH?HI?IPHPI@@QIQAI?PHH@GI@PGOHHHP@QGPG@PAHHI?HQGQPH@@HGH@GQH?APHPHO?QGGGGQPIRH@I@GHOP@@APQPHGPOHQGGHOQP@HHO@HHG?IOIPHGA?H?HAGGGAHPP?HPPHAHG?H?P@?PIQI?HHGP?@OGPIGGGOHHHHOPH@HGGA@OIH@P?HQI?GGPPQOQHGIO@@P@IQHOHOQA@OIGHHPGHPHAG?G@HGIIGIIHOGO?AHHOH?HGHG?@H@GG@AGHAHIGH@HPHGHH?HA?OHGO@QI@PHHH@@OGP?HQGHH?@HHGA?O?GGGQHIHQH@HQHHIHG@Q@QH?GGI?@HHO@GA?HIAGIH@HA@PGIOHGQ?QPHAGHA@??H@PO?P@GIHO?PQH@II?P?IOAH?PPHGIPH?QPOGG@IHG@GIGA?PGIPPHOOPQPHHAHIOI@?@GHQ@HPI@P@@@A@OIAP@GQH??IHHOIP@?AH?HI@YGGO@PGPHHO?GQQ@I??@H@GHOH?Q?AQHGG@QIO?@GG?HPPHA@IOP@?G?P@HOI@@HPO?GAHH@@GH?HG?@@?IG@IIIIIQ?HG?IH?HGG?QHH??GHPA??GH??@IHHI?OGHG?AG?AGCPPQI?@HG?A@IG?@GIGG@H@@HQ@@HG?G@G??GG@GI?HH@G??PH?OA@P@@HO@GH@AGOHPAHG@G?GHIOPPHOGHIG@HHGOH?@HGHGIPG@?GIGG@IGOG@PGGH?IG@?@GPGHH?HPHG@@?I?H?HHIP?I?G@@O@HP@?H?H?G@GH@HP@@GGHG@HHGP?@@G@IQQGHHH?G@H@GHIAG@GI@P@O@@@@PPG@HAPA@?GIG@HGO?AA@GG@@P@H??P@AQ?QH@PHHGG@HHAOGHGI?AIHO?HH?GHA??G@QH?G?A?@?HOG@A@IHHHIPAAHI?GH@@GHIIO@HPQGPH?@AA@GAHHGGHPGI@HIHIHGGIHGI@PHHHGHG?@@?@GIH???GO?IQPQ@@A@GGAHGPH@PI@G@@QPPO@@?A@I@?@P@?IG?P@H@?IGOQ@@I@GG@H?IA@A?GH@AG@HP?GHGHAHIGxd@xd@kr@gp@lp@}r@gu@yt@`o@mt@|q@hm@jo@}v@zo@dq@tp@dr@po@wo@yl@ap@ov@uz@{q@kt@cu@ku@dj@xn@np@~p@~r@{t@to@w|@es@by@py@qy@tz@s_Azm@fp@br@yr@ct@}u@bx@l}@wh@}o@vt@_u@nu@zu@jw@sw@`x@dx@m|@y|@}`A{aApg@ql@ks@ts@~u@nv@rv@fw@hw@sx@}x@_y@gz@s|@n_AvaAecAxeA}f@cj@kj@bk@ok@go@xr@vs@gt@xt@`u@bv@mv@tv@`w@yw@ky@ly@_z@rz@i{@_|@r|@x|@wg@ch@ki@qi@aj@bj@xj@pk@vk@`l@ul@~l@_m@nm@kn@co@uo@op@zp@`q@ar@sr@ms@rs@it@nt@~t@av@dv@|v@aw@dw@~w@gx@`y@oy@zy@bz@vz@p{@s{@v{@z{@d|@j}@j~@x~@z~@t_A|_Af`Ay`AiaAoaAdbAgbArdAsgA{e@`f@bg@hg@jg@lg@mg@og@ah@kh@~h@ui@}i@~i@_j@jj@nj@tj@`k@jl@cm@vm@fn@hn@tn@do@eo@fo@_p@mp@lr@or@qr@tr@cs@xs@ht@rt@hu@mu@qu@kv@vv@bw@gw@{w@nx@ux@ay@ry@vy@yy@cz@dz@fz@mz@oz@a{@f{@m{@a|@l|@z|@~|@_}@`~@g~@m~@u_Ax_A}_Ap`AfaA~aA_bAabAobAqbAsbAtbA{bAbcAccAncArcAadAkdAmdAudAzeAdfAlfAwfAfgAwgA|gAyd@{d@|d@}d@~d@qe@se@te@ue@ve@we@xe@ye@ze@|e@~e@af@qf@sf@tf@uf@_g@`g@ag@cg@dg@eg@fg@gg@ig@kg@rg@sg@ug@yg@zg@{g@|g@}g@~g@_h@`h@bh@eh@gh@qh@zh@{h@|h@`i@ai@bi@ci@di@gi@hi@ii@ji@li@mi@si@ti@vi@wi@xi@yi@zi@{i@|i@`j@fj@gj@hj@ij@mj@oj@pj@qj@rj@sj@uj@vj@zj@|j@}j@~j@_k@dk@ek@fk@gk@hk@ik@jk@kk@lk@mk@nk@rk@sk@tk@uk@wk@yk@zk@{k@|k@}k@~k@_l@al@cl@dl@el@fl@gl@il@kl@ll@ml@sl@tl@vl@wl@xl@|l@}l@am@bm@dm@fm@gm@jm@lm@mm@pm@qm@rm@tm@um@xm@ym@|m@}m@_n@`n@cn@en@jn@qn@sn@un@wn@{n@|n@~n@ho@mo@no@oo@ro@so@cp@hp@jp@kp@|p@aq@nq@pq@uq@xq@~q@_r@cr@fr@ir@ur@vr@wr@as@ps@qs@zs@|s@~s@`t@bt@et@ot@pt@qt@au@bu@ju@lu@ru@|u@cv@gv@iv@xv@zv@{v@~v@_w@iw@lw@mw@nw@pw@rw@tw@xw@_x@ex@fx@jx@px@rx@xx@{x@cy@ey@gy@iy@jy@ny@sy@ty@uy@wy@{y@|y@ez@wz@yz@{z@_{@`{@c{@e{@j{@l{@r{@t{@u{@w{@|{@}{@~{@b|@f|@g|@j|@n|@o|@u|@{|@c}@d}@g}@k}@m}@u}@w}@x}@z}@{}@~}@b~@f~@h~@k~@q~@v~@{~@~~@`_Al_Ao_Ar_Av_Az_A{_A_`A``Ab`Ad`Ae`Ah`Aj`Al`Am`At`Au`Av`Aw`Ax`A|`A`aAaaAhaAkaAnaAqaAwaAxaAcbAfbAibAlbAmbAvbA|bA~bA`cAocAvcAwcAzcA{cA|cA~cAcdAedAndAsdAtdAbeAgeAieAjeAmeAteA|eA}eA_fAbfAffAhfAjfAkfApfAggAigAkgA}gAjhA`iAziAzd@_e@`e@ae@be@ce@de@ee@fe@ge@he@ie@je@ke@le@me@ne@oe@pe@re@}e@_f@bf@cf@df@ef@ff@gf@hf@if@jf@kf@lf@mf@nf@of@pf@rf@vf@wf@xf@yf@zf@{f@|f@~f@ng@qg@tg@vg@xg@dh@fh@hh@ih@jh@lh@mh@nh@oh@ph@rh@sh@th@uh@vh@xh@yh@}h@_i@ei@fi@ni@oi@pi@ri@ej@lj@wj@yj@{j@ak@ck@qk@xk@bl@hl@nl@ol@pl@rl@zl@{l@`m@em@im@km@om@sm@wm@{m@~m@an@bn@dn@gn@in@ln@mn@nn@on@pn@rn@vn@yn@zn@}n@_o@ao@bo@io@ko@lo@qo@vo@xo@yo@{o@|o@~o@`p@bp@dp@ep@ip@pp@qp@rp@sp@up@vp@wp@xp@yp@{p@}p@_q@bq@cq@eq@fq@gq@hq@iq@jq@kq@lq@mq@oq@qq@rq@sq@tq@vq@wq@yq@zq@}q@`r@er@gr@hr@jr@mr@nr@pr@rr@zr@{r@|r@_s@`s@bs@ds@fs@gs@hs@is@js@ls@ns@os@ss@us@ws@ys@{s@}s@_t@at@dt@ft@jt@lt@st@tt@ut@wt@zt@|t@}t@du@eu@fu@iu@ou@pu@su@tu@uu@vu@wu@xu@yu@{u@_v@`v@ev@fv@hv@jv@lv@pv@qv@sv@uv@wv@yv@cw@ew@kw@ow@qw@uw@vw@ww@zw@|w@}w@ax@cx@hx@ix@kx@lx@mx@ox@qx@tx@vx@wx@yx@zx@|x@~x@dy@fy@hy@my@xy@}y@~y@`z@az@hz@iz@jz@kz@lz@nz@pz@qz@sz@xz@zz@|z@}z@~z@b{@d{@g{@h{@k{@n{@o{@q{@x{@y{@{{@`|@c|@e|@h|@i|@k|@p|@q|@t|@v|@||@}|@`}@a}@b}@e}@f}@h}@i}@n}@o}@p}@q}@r}@s}@t}@v}@y}@|}@}}@_~@a~@c~@d~@e~@i~@l~@n~@o~@p~@r~@s~@t~@u~@w~@y~@|~@}~@__Aa_Ab_Ac_Ad_Ae_Af_Ag_Ah_Ai_Aj_Ak_Am_Ap_Aq_Aw_Ay_A~_Aa`Ac`Ag`Ai`Ak`An`Ao`Aq`Ar`As`Az`A{`A~`A_aAbaAcaAdaAeaAgaAjaAlaAmaApaAraAsaAtaAuaAyaAzaA|aA}aA`bAbbAebAhbAjbAkbAnbApbArbAubAwbAxbAybAzbA}bA_cAacAdcAfcAgcAhcAicAjcAkcAlcAmcApcAqcAscAtcAucAxcAycA}cA_dA`dAbdAddAfdAgdAhdAidAjdAldAodApdAqdAvdAwdAxdAydAzdA{dA|dA}dA~dA_eA`eAaeAceAdeAeeAfeAheAkeAleAneAoeApeAqeAreAseAueAveAweAyeA{eA~eA`fAafAcfAefAgfAifAmfAnfAofAqfArfAsfAtfAufAvfAxfAyfAzfA{fA|fA}fA~fA_gA`gAagAbgAcgAdgAegAhgAjgAlgAmgAngAogApgAqgArgAtgAugAvgAxgAygAzgA{gA~gA_hA`hAahAbhAchAdhAehAfhAghAhhAihAkhAlhAmhAnhAohAphAqhArhAshAthAuhAvhAwhAxhAyhAzhA{hA|hA}hA~hA_iAaiAbiAciAdiAeiAfiAgiAhiAiiAjiAkiAliAmiAniAoiApiAqiAriAsiAtiAuiAviAwiAxiAyiA{iA|iA}iA~iA_jA`jAajAbjAcjAdjAejAfjAgjAhjAijAjjAkjAljAmjAnjAojApjAkrA???????????hD??qA??????tA?????tA?qAqBiD?qD??vD????pBpKsBzDqB?pBlBuKvK?vDqBtAPqD?????sB?bL??zDpB?A???????{B?????tA?AM`@??BA?A??Q@??AAA@?sB??B?C?pLB?@C@N??B@??mB]?@?B??@SBA@AB@B?~LBC@?mB@CBqA?B?vA??B@AB?HO?@?AO?@??qA?@BCCAB@BN?A@@?s@B@A?gKuA?D\@?C???O@BhK@A@@BB@?EACAA?A?H?DtL@AC???C?@F??X@M??AB?@J?@D?CDC???DSA??C@C[OBgM@|B?@?CATaC?B@\??@?C?hMA?G??@B]?`@B??DACABBED?B?@@?A@AA@BAAC?G?K@?BA?Ap@?jBQAA@AA@?CBAG????BC??@C@@_@eAA@|B?@@?CC?C@@C@A???BCSA??Ej@@C@@AAhC@`@@@??Ci@@EC?X?AB@?L@?A{BABB??DB?CN@@@@I?uE?@BjC??C}BD@@B?CAA?xM?CBA@??Dk@?CFCMDGG@nE@sE@EAOC@@?BY?A??C@nMC?C?XBBDAA]ACB??CAbEhAABAA@BB|BAAC@CCeAeDC?i@@@AoEBCC?JA@}DXD?@@?MB?AGBc@E?E?n@cB@|DCAA@?B?LAl@e@?C@m@?@@CAeN@?A@@C???@@AA??AB@@@t@BA@A@@??AbM@BAEA@BD?@B??A?A?AAbNDw@l@@SC@AA]AG?BBh@BC?eC?AuA?BeAA@BBAA@?DBDCAJoCaBKDEBz@CBA?A?Ar@?@@@BCDE?~NAT@?EB?@?H@@@B?@@jEGC@@BCAB@DCE??|NBlNFvMB?ABE???CCCAJD@???@A@A@vEBA@?AG@?BCKm@?B?B??N?Aw@?AJCA@@?CDG?AAa@EBjAk@?pC?`AAH@H@AABA@d@@AfBfAE{@A?A@f@AAA@A?@D@?C@AA@?DA@@xLA??@iA_M@BCABD@@@`@AABAB@X@D?@B?@_A@cA@@@d@@f@@aAD@?C@BeB?dBA?dF?@@K`NA?tC?@??M@y@BD?E?B@CBDC?@?@AbA?@?d@CdNG?@BABB@yABwC@?@@BAA@?@V?hAA`@@?B@?C@@No@@DAA@@BeOD??B?@gBKC?zM@B@AE??@??A?@@AD?V?\d@??i@@D??_A?AB@?AB?AO?@sOCa@jC?bCUz@@l@?g@ABXBvAA@A?oMD@BA@@R??A?g@kC_A@@@@hCA@?VB@C?@G@B?\ACABz@DMCCc@???|AA?@BA{@?@?@EIB?@??@|@v@BnNA\?a@jC@??@q@@BB~AC?Ak@@A?pC@A?BvC@DaCKNDf@cNdBsE@CpN?@uO?@BbP?Bl@@ABA_EA|CA@GFhCAAxC@@??nCAn@DAyA?g@B@AB@C?mPCCP?{MD@AfFGd@dCg@@C{C@CAQWNGAmAKmA?EDD{AC@?AA@ABByC??O@@CB@?Bx@CCQP@nCCj@?CpMACBs@?@A?L@@?@AAwMfCDMA@C@BBB@J?[A?cC|AAAOK@@@@jABsP@BEB}ABAJlEcCAAG?@A?@xEB@AACB@@fAf@Ce@C@tPbAAuA`FG@?ABAa@AAAA@CL@A??B@B?BBs@?vA@?L?A?C@JAwACBN?AA?rPcBBB@DDpOiF@zN@AEE@dBzA@@@{@@QlACrF}@CAAAAAB|C@AbFaF?AAABv@@@@B@KC?AB`B@De@?l@nF_DDa@@@A@?CC?@@CBCvPcB??a@oFhPJ@qOg@?XkCbA@o@ADCjN?CCQ?C@PCfAn@D?BjADo@D@cP?`@A@Aj@AB???AK@fABuEA?@ApFAEA}NlEDG?B@@B@`B@S@?AmA@CBkF@BAvA?U?@cBbB@@DLB?HQsFA@@AB@EwF?ABkO?@GBN_E?@}MjF@@CC@?OA@?tM?AwPCAnEAgBCkC@?CDDBbCvEC@@wEADACxN??@K?@@DC?A?xA?X@DBB?~OSBDB???hAdAfEBDxCDk@lAf@Xa@BBCB|@A?B@D?EBg@D@d@BAhAA@PGV@?ADB?A?M{@?ABBBeC?A|A@?@??yPqPwNCf@B@F_PCA@@@A@@?G@dMBA~C@jA?s@ACbC@@@@@gAGAAv@@@g@|OxAB@gF@@A?AuCYCvFhQsF?@CA@A@@fFAy@A@MCDcF?@@@DA@{C\CAe@BDADuCdBfB@AB?B@@AAeC|@@@nPB??@@BB?FB?B@B?@@yF@?AfAAK{A@??e@AA@?@bBjEiA?mAL|@@?@ABBBAAw@A??ULA@t@A{E@B?A@@BAA@@W@lAB@BcAA@?A`BG@wC@A@m@Ao@@A?y@B@@??}F?_G???@rFUB?uP@zFAB@?@MCD?VAAAB~A@AD@oAQE@s@@~C?|FoCBA`DKAAi@?@G_OA@AA@BB?A@AB@rE@AA@AAA@z@ACBHA|FA|A@pCnQ?@A}@@A@ABuABHJ?AB@CA?B?@bA@A|@?@@@B@f@C`G@@BCBAAA@BCbQq@AFS?B?@@@?tF@lA@~AB?c@A@H@@kEBAtCBVA}Qi@?t@xCAAAM@qQ@B?LB@JHAlPAA@M}LAAA?jABtFiCCA@aBoFA}@ABcFKK@A?Ae@@mEF??@@@@@K?@AYBB@AAo@aFDn@|@?gPBAI@?JeAKAA@@?AB@?C@s@?@|CA@EvF@}@A?Q@iF]BoQ@ABB@e@@BBAA@BB?@@`D?B?~ABB?AAA~CiP@AA@A?@?AB@}CAA@@_RAA{OaB@?QB@?A?B@dQlC@AsQ@gB?AKzFUoA@yAj@DDBCoA@nA@yCQ`QBA@?{N@B?B@BMrQf@@?_QBgB?LAAA@iAAoAAA@@oA@lAnCo@A@B@@?fEA?}@CaDBB@@@?D?@@nAa@CAoC@?Y@?@@BwFd@D?JcA@Ac@@\{@A?B@BA`@a@AjPA@@D@AA@??`B@ADA]QCC@?GB@@PBAMaGB?@A@@KAJB@B@w@A??UAUAK@BUM@?zC`F@BU@bF{@BmAC?M@y@yEA@MDEkEBpPaDABC@iQ@?BCABbBH@@@B}C@?AeBBAB@B@vCDAAB?@A?@ASCBCB@BABBAAByAPBT?@@yFAAAA@@hO@`RrE?CB@`G?@@B@D?BBzAAIB@BAaB?Ar@BAABBiAVA`DIm@?aDbBAOABuMsNpF@AUBwCUo@B@xEB@A@A@@AA@@pQ@?c@tEu@BBPFjFBVMA@BB@AT?@J?A?B?C?D?E?F?G?H?I?J?K?L?M?N?O?P?Q?R?S?T?U?V?W?XbGBcGDeGF?Y?Z?[?\?]?^?_@?`@?a@?b@mG^oG`@pGb@qG_@bDc@?d@?e@?f@?g@?h@?i@?j@?k@?l@?m@?n@?o@?p@?q@gGCdGEfGYjG[lGr@?s@?t@?u@?v@?w@?x@?y@?z@?{@?|@?}@?~@?_A?`A?aA?bA?cA?dA?eA?fA?gAfDhA?hA?iA?jA?kAsGDhGYuG\?lA?mA?nA?oApA{@wG}@yG_AzGaA|GcA~GeA_HgA`HhAhDpA?qA?rA?sA?tAiBuA~@EtGZkG\bHvA?wA?xAmHFiGZnHlA?vA?yA?zAkDYaHlA?{A?|A?}A?~AhB|@xG~@dD`A{GbA}GdAeDfA?_Bp@}@dH`ApHcAgHfAfDgAgDhAlD~@dD`B?aB?bB?cB?dB?eB?fB?gBoHZ?hB?iB?jBwH_AeHbAqHeAhHgAvHiA?pAkHrAlHtAiBkB?lB?mB?nB?uA?oBoDoB?pB?qB?rB?sB?tB?uB?vB?wB?xB?yB?zBkB`AsHdArHgAiHiA`IqAjDsAiBtA?kBdImBfIuApDoBgIqBmBsBrAaAfHdAlIgAmDpAaIsAoIkBqInBnDoBpDpBlB{BkB`B?|B?}B?~B?_C?`C?aC?bC?cC?dC?eC?fC?gC?hCsA|ByI~B{I`C}IbC_JdCaJfCcJhChBiC?jC?kC?lC?mC?nC?oC?pC?qC?rCoB}BzI_C|IaC~IcC`JeCbJgCnBbA~HfAuHhAgDiAmIrAbItAuJcAtHgArDsC?tCyJdAtIuC?vC?wC?xC?yC?zC?{C_AeA_IhAuDpAuItAcI|C?}ChJjCiJlCkJnCmJpCoJrCpJ~BdJaCrJdCgJgCRfAvJhAjHqAjD~C?_D?`DIgArDpA_KtApIlBeInBxIoBoDpBlBrBtBkCjJmClJoCnJqCuBgAmDjA?aDZuBhIwBjIyBh@hAuDsC?bDwDlCaKoCoKrCtKmCnKpCqKvBiIxBkIzByDwBrKzBp@cD?dD?eD?fDcK_CqJbCfJeCtJhCwK`CeJcCsJfCsKhAfKrAxJkB?|CyKaCdKeCxDnCbKqC[iAwJsA?gD?~C{JxC?hD?iD?jD|KbCxKfCFpAiKkBwIuArIpB}KoCvBxBJqAnItA`K}C`LpCcLqC~KcCzKgCaLyBZkD?lDPrAwB~CxDmDInD?oDxBdCeKhCLsAvI|CsAaBxHcB?pDStAQzB}H[vGqD~DeCfLfC`@rCRnDLrDeL\?r@?sD?tD?uDi@tAjKmBsDoBtDqB?vD?wDyBlA?xD?yD?zDFjAiD{D?|DzBvA?}D?~D]kA?{DyBr@?_E?`E?aE?bE?cEiLwAyB]nG_@bDa@rG`@cD]jL`@cDb@kLa@?dElLeE?fEzBmAcHgE?hEgLgCNiE?jE?kE?lE?mE?nEIoE?pENkB{K}CHjEnLlE?qE?rE?sEVhCxBtE?uE?vEOlBkKwCaEmBsDwCrByCLwE?xEsL~C{DhD}DjDO|CrAyE?zEN{Ek@}CoB|E?}E?~E?_F?`FqLkEoLqEdElE?aFrAbF?cF?dF?eFb@qErLsEbEnBnDwC}BfF?gF?hFvBiF?jF~BuA_LqBaAoBtDrBZkF?lF?mF?nFsAoF?pF?qF?rF?sF?tF?uFOkB?vF?wFIxFl@vFJyFwAoBlKqB`CoBsIrBxAwFb@oE?zFHwCrBhDxB{F?|F?}F?~FWpBmKsB[pAr@qB?_GI`G?aG?xFHbG_CcGSgDwBwCaMiDErBvBdG?eG?fGXsBZgG?hGFiGL~C`MxC|DiDFjG?kGj@pEIP~@lG?mG?nG?oG?pG?qG?rG?sGLtG?uG?vGY_DEvD?wGcExGWyGcExEHzG?{G?|G^}G?~G?_H^`H?aHIbHhBcHb@aF`ArE_@dH?eHPyFTfH?gHFhH?iH?jHdC|G~@kH?lH?mH?nH?oHm@`D?pH{BqHRrHu@uGHsH?zGdAtHb@nEq@uHHvHXwHFxHgE|F?yH?zH?{H?|H?}Hh@~HE_IY`IM{DPtGmLaI?bI?cI?dIh@uCzJwC}BzC~JeIaAfIdAgIIhIh@iI?jIu@pHEkI_BvC{DyC}J{CdLbByHdBr@rBFkGzBxDhLlI?mItBnI?oI?pI?qIFiHp@rI?sI?tI?uI?vI?wI?xI?yI?zI?{IV|I?}ImEzGb@`IhEhGI~I?_J?`JgAaJ?bJ~BoBxAcJq@oDu@dJsAeJt@fJ_@gJLhJRgADsBKpHR`GtBiJ?jJ?kJ?lJ?mJ?nJsMoJ`AoE~BrHfNjJhNlJiNnJLdIq@eIuBpJaAwClCqJlCrJ?sJdCtJP~ChEuJ?vJ?wJ?xJ?yJy@wCoEeIiCcBzHeBjBzJv@{J^|JE}Ju@tGF~JI_KyMzCOgIW`KiAmEnBaK?bK?cKWdKmNwCJpA?~JeMhD^eKw@xH^}E?fK?gKaCzFpEhK?iK?jKmCxCeElFyLkKPlKbAwD`@mKcAnK`AoKwApKyExC|JzCb@qK?rKzEdB{HfB|HsK?tKTgJE{B?uK{AxEV}IgAvK?wK?xKZyKLzKn@|DS~CfMmG?{KlMnHrNiD~E~CuLiDY|Kx@qKFsC|EfK?}K?~K?_Lz@jDR`LFgITtH`O{K_FaLfCdJi@iEFtCj@rJ_CbLW_GRaG}EyC?fFwLhFdEwCcMjD_@_Jc@_JZcLfC~C|E~EvLeFmCdLeBuKZeL?fL?gL?hLlDiL?jL?kLm@|KwBlLfOfFgAmL?nL?oL?pL?qLWrLTsL_@sL~@tL?uL?vL_FoHFwLIwC?xLmOgFr@_ITyLYoEnBzL?{LR|LrA}L?~LgNkJtE_MU|DIxC}AjH_@bHW`MFaMgAsIqEuI?bM?cM?dMgOxCiEeMhA}IpEoI|MqI?fM?gM^hM?iM?fH?tH?jMJ~J?kMzEpDlO~C?lMj@zFsCmMd@sB]nMoNnEIgJ_AfArOxCYoMdOmHmMoHqCyC^pM?qM?rMiCsM?tMe@|DRoEp@uMaPqHaOwCrBiDwDvM?wM?xM?yM?zM?{Mb@rKaEnBg@sBO{EQ|M_@}MEwHH~MJ_NgFhDHpEUpHp@`NqEaN?bNy@vGpAcNb@pEfBtCtNiKuNdN?eN?fN?gNHhN_BxHPwEwEsJgClDSiGNiGaNbJcCwDyCzCzOlM{A~C~DiN?jN?kN?|ItC`JdAlNx@mEzCxLv@mN}C{CInN{CqHHoEvOtI?aNrCeBjBoNOpNTeHnOqNHrNIaGNsNlFaN?tN?uNr@}JzCxCiEjDgClN\qHn@gI}AiHx@jIpAvN?wNkPiDt@jHx@xN_DgJ`ArJmCxLzPhDNuAoPjK?yN?zN?{NEsBcAsEsCeBmFfBR|NzA~CbOjD[aM`CyGyD}NaA~Nh@vCkMlH`EfDdFvGpA_O[jGn@iGH`I\zK}@eIv@yHqM{H}A`O?gIt@kG^aOmFgBxOhDkFzFOiGIdH~EwCjOjL[jAeQiDxPtN?bOqFcOeB_GrClDlFuI?dOFkAuCsEeFpEqNxCyN{CuBeOgQjDuFmH{PjD{E|Dl@iGxFvI~MxI?fO_N{IJkMwA~N?~N[gAu@gIvN}IjQnHZgO?hOnAoN]gI}OnH?iOhFqMT}MWjOx@kOjMaHk@gIfQkLkDlO?mO`CpBHoMY`DEnOtO~L?oOrCfBeEpOkBqO?rOR~IIxHWsOm@~Cq@tO{FrOiO_F?uOcO_LkAvO~@wO?xO?yO?zO?{O?|O?}O?~O?_P?`PuQxOvQaP?bP?cP?dP?eP?fPyQyO?gP?hP?iP?jP?kP?lP?mP~FgP?nP?oP?pP?qP?rP?sP}F~O~FzOwQ|OzQ{OxQ}O{Q|O_G_P?tP?uP|QvPaQzHrM|H?wPw@|DTxPc@gJtQuOc@vG}PyN~P{NkA}KkAyP|PiDeFzF_BwCgEzP?{P_@xHyOkMcQjH_@eHN|CxFbMwOdMFrL_@PzLpF{LrF|LtFLgIzAwCLxG`E|PlQoHS}PhF~P?_QLgDJ|DT`QRwCdAaQvCvG[bQ{FcQ?dQoOeQ_DxFaGjDfBbDuFtKdPwMePyMfP|PoBfQ?gQ?hQ?iQ}EhDnFdInAgB\|D?qHgCjQ?kQk@pN^lQh@kO_BmQ[sCkAgKI_JFnQ_CjFnAzJsChON`L]{DkQoH^oQiMpQ`PqQeAeIK|D~QqF?rQz@eMkAsQmQrMYpEqFtQNwCqChDZuQqCzCkNkJZvQ?wQ</div>
<div id="globalStacks" style="display:none"></div>
<div id="methods" style="display:none">@??A??B?????B??C??B?????B??D??B?????E??F??C?????E??G??C?????E??H??C?????E??I??C?????E??J??C?????E??K??C?????E??L??C?????M??N??B?????M??O??C?????M??P??C?????M??Q??C?????E??R??C?????E??S??C?????E??T??C?????U??V??@W??F?W??X??P??gH?Y??Z??P??s@?Y??Z??@A?OB?[??Z??PI?[W?[??\??PL?cY?]??Z????????^??Z??B?????E??_??C?????E??`??C?????E??a??C?????E??b??C?????E??c??C?????E??d??C?????E??e??C?????E??f??C?????E??g??C?????E??h??C?????E??i??C?????E??j??C?????E??k??C?????E??l??C?????E??m??C?????E??n??C?????E??o??C?????E??p??C?????E??q??C?????E??r??C?????E??s??C?????E??t??C?????E??u??C?????E??v??C?????E??w??C?????E??x??C?????E??y??C?????E??z??C?????E??{??C?????E??|??C?????E??}??C?????E??~??C?????E???@?C?????@@?V??pS?WC?A@?B@?@U?wL?C@?D@?PJ?sC?C@?E@?@A@sK?C@?F@?PD??H?G@?H@?PG?GC?I@?H@?pA????J@?K@?PG?wD?L@?M@?@A?CA?N@?M@?PA?{y@N@?M@?@?????O@?P@?B?????O@?Q@?C?????O@?R@?C?????O@?S@?C?????O@?T@?C?????O@?U@?C?????O@?V@?C?????E??W@?C?????E??X@?C?????E??Y@?C?????E??Z@?C?????O@?[@?C?????O@?\@?C?????O@?]@?C?????O@?^@?C?????O@?_@?C?????O@?`@?C?????E??a@?C?????E??b@?C?????E??c@?C?????E??d@?C?????E??e@?C?????E??f@?C?????E??g@?C?????E??h@?C?????E??i@?C?????O@?j@?C?????I@?H@?`B????C@?k@?PF?oM?l@?m@?aE?cN?n@?o@?aW?KJAp@?q@?AS?OX?E??r@?C?????s@?t@?B?????s@?u@?B?????E??v@?C?????E??w@?C?????E??x@?C?????O@?y@?C?????O@?z@?C?????O@?{@?C?????O@?|@?C?????O@?}@?C?????O@?~@?C?????O@??A?C?????O@?@A?C?????O@?AA?C?????@@?V??@M?KC?BA?CA?@A?cE?DA?CA?P@?GH?DA?EA?`I?CG?FA?GA?pW?gF?HA?IA?@?????^??JA?B?????O@?KA?C?????C@?k@?@W?GN?C@?LA?pA?gO?A@?MA?@B?WH?A@?MA?PG?OI?NA?MA?pE?WQ?OA?MA?`D?[D?PA?MA?pH?O`?QA?MA?@A?SB?QA?MA?@a?CE?QA?RA?@`?OG?SA?MA?@@?wB?TA?UA?@?????^??MA?B?????C@?D@?@F?WC?A@?VA?@A??G?OA?VA?`D?CF?PA?VA?@Z?CY?QA?VA?@A?KO?QA?VA?@U?_Q?QA?WA?@`?gS?SA?VA?@@?{A?SA?XA?@?????^??VA?B?????O@?YA?C?????O@?ZA?C?????[A?\A?C?????[A?]A?C?????^A?_A?C?????`A?aA?B?????`A?bA?B?????`A?cA?B?????`A?dA?B?????O@?eA?C?????^??fA?B?????O@?gA?C?????O@?hA?C?????O@?iA?C?????@@?V??ON?KC?O@?jA?C?????C@?E@?pr??K?l@?m@?`E?cN?n@?o@?pL?oIAA??kA?B?????O@?lA?C?????`A?mA?B?????`A?nA?B?????`A?oA?B?????BA?CA?EK?CF?E??pA?C?????QA?VA?uV?cQ?`A?qA?B?????`A?rA?B?????p@?q@?a@?cW?E??sA?C?????O@?tA?C?????E??uA?C?????E??vA?C?????E??wA?C?????O@?xA?C?????O@?yA?C?????E??zA?C?????E??{A?C?????E??|A?C?????O@?}A?C?????O@?~A?C?????E???B?C?????E??@B?C?????E??AB?C?????E??BB?C?????E??CB?C?????E??DB?C?????@@?V??_P?OC?E??EB?C?????E??FB?C?????E??GB?C?????E??HB?C?????E??IB?C?????O@?JB?C?????O@?KB?C?????O@?LB?C?????O@?MB?C?????O@?NB?C?????B??OB?B?????`A?PB?B?????`A?QB?B?????O@?RB?C?????`A?SB?B?????`A?TB?B?????QA?MA?pY?oD?UB?VB?AX?C~?UB?WB?Q??_B@O@?XB?C?????O@?YB?C?????J@?K@?@Q?GE?ZB?[B?qD?[D?O@?\B?C?????C@?LA?`??cO?ZB?]B?`V?OJ?^B?_B?aD?sE?`B?MA?QB?kC?`B?MA?aH?oD?O@?aB?C?????J@?K@?PD?sD?`B?]B?AB?_K?`B?MA?AA?KD?`B?MA?qI?oD?`A?bB?B?????`A?cB?B?????`A?dB?B?????FA?GA?qM?KF?FA?eB?aJ?[H?BA?CA?@N?KF?BA?fB?qF?{G?gB?hB?Q??Od@iB?jB?AV?Cc@C@?k@?pD?gM?kB?lB?A@?SL?mB?nB?a??SE?mB?oB?QD?[D?pB?qB?a@?SJ?rB?sB?qK?oK?tB?uB?QF?CN?O@?vB?C?????O@?wB?C?????E??xB?C?????O@?yB?C?????`A?zB?B?????QA?MA?pW?cD?{B?|B?AE?_M?}B?M@?q`?[I?}B?hB?a@?sF?O@?~B?C?????O@??C?B?????E??@C?B?????O@?AC?C?????FA?eB?A??GH?FA?GA?qN?OF?DA?BC?AM?cO?CC?DC?qD?sV?BA?CA?P??_E?BA?EC?@??wF?O@?FC?C?????O@?GC?C?????O@?HC?C?????E??IC?C?????E??JC?C?????E??KC?C?????E??LC?C?????E??MC?C?????E??NC?C?????E??OC?C?????E??PC?C?????O@?QC?C?????O@?RC?C?????SC?TC?B?????@@?V??eT?cC?O@?UC?C?????O@?VC?C?????O@?WC?C?????@@?V??PN?KC?XC?YC?PC?oH?ZB?]B?pW?OJ?^B?_B?a??[F?^B?ZC?qA?wI?ZB?]B?`N?CJ?^B?[B?a@?GA?E??[C?B?????C@?D@?@??CC?E??\C?B?????E??]C?C?????E??^C?C?????E??_C?C?????O@?`C?C?????O@?aC?C?????O@?bC?C?????E??cC?C?????E??dC?C?????E??eC?C?????E??fC?C?????^??gC?B?????O@?hC?C?????SC?iC?B?????^A?jC?C?????O@?kC?C?????E??lC?C?????`A?mC?B?????O@?nC?C?????O@?oC?C?????SC?pC?B?????}B?M@?af?oI?qC?rC?a??cC?qC?rC?a??gS?UB?rC?a??c^@sC?rC?Q@??V?O@?tC?C?????O@?uC?C?????`A?vC?B?????E??wC?C?????E??xC?C?????E??yC?C?????SC?zC?B?????`A?{C?B?????O@?|C?C?????}C?~C?B?????`A??D?B?????O@?@D?C?????O@?AD?C?????O@?BD?C?????E??CD?C?????E??DD?C?????OA?VA?aD?CF?PA?VA?QA?CX?ED?FD?A@?GS?GD?FD?Q??_H?C@?E@?Pf?cJ?C@?HD?aL?sL?`B?VA?AA?SG?`B?VA?aC?gG?`B?ID?QC?wJ?JD?KD?qA?sb?LD?KD?QA??q?LD?MD?QA??s?LD?ND?qB?Kc?LD?OD?Q??wa?PD?QD?B?????PD?RD?B?????E??SD?B?????E??TD?C?????E??UD?C?????C@?HD?aH?oL?`B?VD?QE?wN?O@?WD?C?????O@?XD?C?????C@?k@?@??SM?O@?YD?C?????E??ZD?C?????O@?[D?C?????OA?VA?qC?CF?UB?\D?AA?_X?]D?[B?AB?wC?UB?[B?AA??Q?sC?[B?qH?SN?UB?rC?a??kO?sC?rC?qL?OV?O@?^D?C?????`A?_D?B?????`A?`D?B?????`A?aD?B?????XC?YC?AA?oH?BA?EC?@@?wF?bD?IA?aO?kW?bD?cD?aD?SQ?rB?dD?QJ?SB?eD?fD?qF?oI?s@?gD?B?????}B?M@?A_?WI?ZB?]B?pS?KJ?O@?hD?C?????O@?iD?C?????[A?jD?C?????O@?kD?C?????L@?M@?AA?CA?N@?M@?QA?{y@N@?M@?A?????O@?lD?C?????ZB?]B?@??cI?^B?_B?a??oE?`B?mD?aF??B?PA?VA?AZ?CY?QA?VA?AA?KO?QA?VA?AU?_Q?iB?jB?aU?Cc@O@?nD?B?????PD?oD?B?????`A?pD?B?????O@?qD?C?????O@?rD?C?????O@?sD?C?????B??tD?B?????^??uD?B?????^??vD?B?????O@?wD?C?????C@?HD?QQ?wL?A??xD?B?????QA?MA?@??kC?BA?CA?@??_E?O@?yD?C?????E??zD?C?????O@?{D?C?????`B?mD?AC?{A?n@?|D?AB?_]@p@?|D?QE?GB?^A?}D?C?????B??~D?B?????FA?eB?aX?sH?BA?CA?PJ?CF?`A??E?B?????BA?CA?PO?OF?@E?AE?A@?OU?BE?AE?A@?SN?CE?AE?aI?wt?C@?F@?QD??H?G@?H@?QG?GC?I@?H@?aB????O@?DE?C?????C@?HD?AT?wL?l@?[B?aK?SD?n@?EE?q??[SAn@?EE?QB?GVAp@?EE?aA?wK?O@?FE?B?????E??GE?C?????E??HE?C?????E??IE?C?????E??JE?C?????O@?KE?C?????`A?LE?B?????E??ME?C?????L@?M@?qE?[A?NE?[B?a@?K??`A?OE?B?????J@?K@?@E?sD?UB?\D?A@?SZ?sC?[B?qA?CL?O@?PE?C?????O@?QE?C?????`B?ID?aE??K?RE?SE?AD????TE?UE?aE????`A?VE?B?????WE?XE?qB?GM?YE?ZE?a??gC?ZB?]B?PV?OJ?E??[E?C?????SC?\E?B?????O@?]E?C?????O@?^E?C?????A@?VA?@???G?O@?_E?C?????`A?`E?B?????ZB?]B?`P?GJ?^B?_B?Q@?gD?^B?_B?AC?{D?n@?o@?qE?gIAn@?mD?a@?O[@C@?E@?@??kH?PA?VA?PA?CX?ED?FD?@@?GS?GD?FD?P??_H?WE?XE?pB?GM?YE?ZE?`??gC?A??aE?B?????PD?bE?B?????E??cE?C?????O@?dE?C?????O@?eE?C?????C@?E@?@o?oJ?`B?VA?QA?cG?`B?fE?q??CI?A@?B@?A@?GL?QA?WA?A`?gS?SA?VA?A@?{A?SA?XA?A?????PD?gE?B?????O@?hE?C?????QA?RA?A`?OG?SA?MA?A@?wB?TA?UA?A?????E??iE?C?????}B?M@?AI?GH?E??jE?C?????^??kE?B?????O@?lE?C?????l@?[B?aH?KD?O@?mE?C?????O@?nE?C?????`B?fE?qA?GI?JD?oE?A??kO?A@?B@?AU?wL?C@?D@?QJ?sC?O@?pE?C?????QA?WA?ah??T?qC?qE?a??cC?qC?qE?a??CS?[A?rE?C?????DA?EA?@??gF?O@?sE?C?????A@?B@?A??GL?O@?tE?C?????ZB?]B?`F?kI?JD?oE?Q@?kO?C@?D@?qE?WC?`B?ID?Q??sJ?[A?uE?C?????LD?MD?QC?Cs?BA?CA?@K?CF?E??vE?C?????^??wE?B?????O@?xE?C?????O@?yE?C?????E??zE?C?????M??{E?C?????O@?|E?C?????UB?\D?A??_X?BA?fB?aL?CH?I@?H@?@A????l@?}E?@???J?O@?~E?C?????`A??F?B?????`B?MA?QF?kD?`B?mD?QE??B?E??@F?C?????E??AF?C?????E??BF?C?????E??CF?C?????E??DF?C?????E??EF?C?????E??FF?C?????E??GF?C?????E??HF?C?????E??IF?C?????E??JF?C?????E??KF?C?????E??LF?C?????E??MF?C?????E??NF?C?????E??OF?C?????E??PF?C?????E??QF?C?????E??RF?C?????E??SF?C?????E??TF?C?????E??UF?C?????E??VF?C?????E??WF?C?????E??XF?C?????E??YF?C?????E??ZF?C?????E??[F?C?????E??\F?C?????E??]F?C?????E??^F?C?????E??_F?C?????sC?rC?aB??V?E??`F?C?????`B?mD?qA?wA?{B?|B?qB?[M?aF?M@?AC?SI?A??bF?B?????O@?cF?C?????^B?_B?P@?gD?^B?_B?@C?{D?E??dF?C?????E??eF?C?????O@?fF?C?????l@?}E?`???J?l@?gF?aC?{F?p@?EE?AG?SL?C@?LA?qA?gO?A@?MA?QA?WH?NA?[B?Q??_P?hF?[B?Q???N?E??iF?C?????E??jF?C?????ZB?]B?pL?wI?[A?kF?C?????O@?lF?C?????ZB?]B?P\?WJ?^B?ZC?Q@?wI?n@?mD?A@?O[@mB?oB?a@?[D?`B?mD?aB?{A?C@?D@?qK?wC?BA?CA?pA?cE?BA?CA?P@?cE?</div>
<span style="position:fixed; bottom: 0; right:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-left: 1px solid #ffc000; border-top-left-radius: 4px;"><span id="produced">Produced by <a href='https://github.com/jvm-profiling-tools/async-profiler'>async-profiler</a>&nbsp;</span><span id='match' style="display: none">Matched: <span id='matchval'></span>&nbsp;<span id='reset' title='Clear'>&#x274c;</span></span></span>

<h1 id="title">Heatmap, CPU</h1>

<canvas id='canvas'></canvas>
<div id='hl'><span></span></div>

<span id='status' style="position:fixed; bottom: 0; left:0; padding: 2px 4px; background-color: #ffffe0; border-top: 1px solid #ffc000; border-right: 1px solid #ffc000; border-top-right-radius: 4px; display: none">&nbsp;</span>
<script>
	// Copyright 2020 Andrei Pangin
	// Licensed under the Apache License, Version 2.0.
	'use strict';
	let root, rootLevel, px, pattern;
	let reverse = true;
	const levels = Array(0);
	for (let h = 0; h < levels.length; h++) {
		levels[h] = [];
	}

	const canvas = document.getElementById('canvas');
	let c = canvas.getContext('2d');
	const hl = document.getElementById('hl');
	const status = document.getElementById('status');

	const canvasWidth = canvas.offsetWidth;
	let canvasHeight = canvas.offsetHeight;
	canvas.style.width = canvasWidth + 'px';
	canvas.width = canvasWidth * (devicePixelRatio || 1);
	canvas.height = canvasHeight * (devicePixelRatio || 1);
	if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
	c.font = document.body.style.font;

    const search = typeof searchIterative === 'function' ? searchIterative : searchSimple;
    const init = typeof renderHeatmap === 'function' ? renderHeatmap : render;

	const palette = [
		[0xb2e1b2, 20, 20, 20],
		[0x50e150, 30, 30, 30],
		[0x50cccc, 30, 30, 30],
		[0xe15a5a, 30, 40, 40],
		[0xc8c83c, 30, 30, 10],
		[0xe17d00, 30, 30,  0],
		[0xcce880, 20, 20, 20],
	];

	function getColor(p) {
		const v = Math.random();
		return '#' + (p[0] + ((p[1] * v) << 16 | (p[2] * v) << 8 | (p[3] * v))).toString(16);
	}

	function f(level, left, width, type, title, inln, c1, int) {
		levels[level].push({left: left, width: width, color: getColor(palette[type]), title: title,
			details: (int ? ', int=' + int : '') + (c1 ? ', c1=' + c1 : '') + (inln ? ', inln=' + inln : '')
		});
	}

	function samples(n) {
		return n === 1 ? '1 sample' : n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' samples';
	}

	function pct(a, b) {
		return a >= b ? '100' : (100 * a / b).toFixed(2);
	}

	function findFrame(frames, x) {
		let left = 0;
		let right = frames.length - 1;

		while (left <= right) {
			const mid = (left + right) >>> 1;
			const f = frames[mid];

			if (f.left > x) {
				right = mid - 1;
			} else if (f.left + f.width <= x) {
				left = mid + 1;
			} else {
				return f;
			}
		}

		if (frames[left] && (frames[left].left - x) * px < 0.5) return frames[left];
		if (frames[right] && (x - (frames[right].left + frames[right].width)) * px < 0.5) return frames[right];

		return null;
	}

    const marked = [];

    function render(newRoot, newLevel, minLevel) {
        minLevel = minLevel || 0;
        if (root && minLevel === 0) {
			c.fillStyle = '#ffffff';
			c.fillRect(0, 0, canvasWidth, canvasHeight);
		}

		root = newRoot || levels[0][0];
		rootLevel = newLevel || 0;
		px = canvasWidth / root.width;

		const x0 = root.left;
		const x1 = x0 + root.width;

		if (minLevel === 0) {
		    marked.length = 0;
        }

		function mark(f) {
			return marked[f.left] >= f.width || (marked[f.left] = f.width);
		}

		function totalMarked() {
			let total = 0;
			let left = 0;
			Object.keys(marked).sort(function(a, b) { return a - b; }).forEach(function(x) {
				if (+x >= left) {
					total += marked[x];
					left = +x + marked[x];
				}
			});
			return total;
		}

		function drawFrame(f, y, alpha) {
			if (f.left < x1 && f.left + f.width > x0) {
                let match = pattern && pattern.test(f.title) && mark(f);
                const fw = f.width * px;
                if (fw < 0.1) {
                    return;
                }
                c.fillStyle = match ? '#ee00ee' : f.color;
				c.fillRect((f.left - x0) * px, y, fw, 15);

				if (fw >= 21) {
					const chars = Math.floor(fw / 7);
					const title = f.title.length <= chars ? f.title : f.title.substring(0, chars - 2) + '..';
					c.fillStyle = '#000000';
					c.fillText(title, Math.max(f.left - x0, 0) * px + 3, y + 12, fw - 6);
				}

				if (alpha) {
					c.fillStyle = 'rgba(255, 255, 255, 0.5)';
					c.fillRect((f.left - x0) * px, y, fw, 15);
				}
			}
		}

		for (let h = minLevel; h < levels.length; h++) {
			const y = reverse ? h * 16 : canvasHeight - (h + 1) * 16;
			const frames = levels[h];
			for (let i = 0; i < frames.length; i++) {
				drawFrame(frames[i], y, h < rootLevel);
			}
		}

		return totalMarked();
	}

	canvas.onmousemove = function() {
		const h = Math.floor((reverse ? event.offsetY : (canvasHeight - event.offsetY)) / 16);
		if (h >= 0 && h < levels.length) {
			const f = findFrame(levels[h], event.offsetX / px + root.left);
			if (f) {
				hl.style.left = (Math.max(f.left - root.left, 0) * px + canvas.offsetLeft) + 'px';
				hl.style.width = (Math.min(f.width, root.width) * px) + 'px';
				hl.style.top = ((reverse ? h * 16 : canvasHeight - (h + 1) * 16) + canvas.offsetTop) + 'px';
				hl.firstChild.textContent = f.title;
				hl.style.display = 'block';
				let details = f.details || '';
				canvas.title = f.title + '\n(' + samples(f.width) + details + ', ' + pct(f.width, levels[0][0].width) + '%)';
				canvas.style.cursor = 'pointer';
				canvas.onclick = function() {
					if (f !== root) {
						render(f, h);
						canvas.onmousemove();
					}
				};
				status.textContent = 'Function: ' + canvas.title;
                status.style.display = 'inline';
				return;
			}
		}
		canvas.onmouseout();
	}

	canvas.onmouseout = function() {
		hl.style.display = 'none';
		status.textContent = '\xa0';
        status.style.display = 'none';
		canvas.title = '';
		canvas.style.cursor = '';
		canvas.onclick = '';
	}

    window.onkeydown = function() {
        if (event.ctrlKey && event.keyCode === 70) {
            event.preventDefault();
            search(true);
        } else if (event.keyCode === 27) {
            search(false);
        }
    }

    document.getElementById('reset').onclick = function() {
        search(false);
    }



    class DataBuffer {
        data;
        pos = 0;
        constructor(encodedData) {
            this.data = encodedData;
        }

        nextVarInt() {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(this.pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

        byteAt(pos) {
            return this.data.charCodeAt(pos) - 63;
        }

        int30(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos) << 24);
        }

        int36(pos) {
            return (this.byteAt(pos++) << 0)
                | (this.byteAt(pos++) << 6)
                | (this.byteAt(pos++) << 12)
                | (this.byteAt(pos++) << 18)
                | (this.byteAt(pos++) << 24)
                | (this.byteAt(pos++) << 30);
        }

        varInt(pos) {
            let res = 0;
            let shift = 0;
            let b;
            do {
                b = this.byteAt(pos++);
                res |= (b & 0x1F) << shift
                shift += 5;
            } while (b >= 0x20)
            return res;
        }

    }

    class HeatmapCollection extends DataBuffer {

        maxZoom;
        blocks;
        zoomToCounts;
        zoomToMaxes;
        zoom;

        constructor(encodedData) {
            super(encodedData);

            this.maxZoom = this.nextVarInt();   // fixme
            this.maxZoom = 3;

            const startMethodsCount = this.nextVarInt();
            const starts = new Set();
            for (let i = 0; i < startMethodsCount; i++) {
                starts.add(this.nextVarInt());
            }

            const lz = new Lz78Data(this, starts);

            let max = 1;

            let prevByte = -1;
            const blocksCount = this.nextVarInt();
            let counts = new Uint32Array(blocksCount);
            for (let i = 0; i < blocksCount; i++) {
                let v = 0;
                let p = 0;
                let hasMore = false;
                do {
                    if (prevByte === -1) {
                        prevByte = this.byteAt(this.pos++);
                        hasMore = (prevByte >>> 5) === 1;
                        v |= ((prevByte >>> 3) & 3) << p;
                        prevByte &= 7;
                    } else {
                        hasMore = (prevByte >>> 2) === 1;
                        v |= (prevByte & 3) << p;
                        prevByte = -1;
                    }
                    p += 2;
                } while (hasMore);
                counts[i] = v;
                max = Math.max(max, v);
            }

            this.blocks = lz.decode(counts);

            this.zoomToCounts = new Array(this.maxZoom);
            this.zoomToMaxes = new Array(this.maxZoom);

            this.zoomToCounts[0] = counts;
            this.zoomToMaxes[0] = max;

            for (let z = 1; z < zoomToGroupSize.length; z++) {
                const size = zoomToGroupSize[z] / zoomToGroupSize[z - 1];
                const nextCounts = new Uint32Array(Math.ceil(counts.length / size));
                for (let i = 0; i < counts.length; i++) {
                    const index = (i / size) | 0;
                    nextCounts[index] += counts[i];
                    max = Math.max(max, nextCounts[index]);
                }
                this.zoomToCounts[z] = counts = nextCounts;
                this.zoomToMaxes[z] = max;
            }

            this.data = null;
        }

        setZoom(zoom) {
            this.zoom = zoom;
        }

        heatmap() {
            return this.zoomToCounts[this.zoom];
        }

        max() {
            return this.zoomToMaxes[this.zoom];
        }

        currentTimeBlock() {
            // FIXME 20 is hardcoded
            return 20 * zoomToGroupSize[this.zoom];
        }

        startBlock() {
            const blockMs = this.currentTimeBlock();
            const timeBlockMs = blockMs * heatHeight * 20;
            return Math.floor(startMs % timeBlockMs / blockMs);
        }

        count() {
            return Math.ceil((this.heatmap().length + this.startBlock()) / 20 / heatHeight) * 20 * heatHeight;
        }

    }

    class LzChunk extends Uint32Array {
        constructor(size) {
            super(size);
        }

        copyWithNext(element) {
            let result = new LzChunk(this.length + 1);
            result.set(this);
            result[this.length] = element;
            return result;
        }
    }

    class Lz78Data {
        data;
        starts;
        lz78;

        tmp = [];
        prevSubTreeId = -1;

        constructor(data, starts) {
            this.data = data;
            this.starts = starts;

            this.lz78 = [new LzChunk(0)];
        }

        decode(counts) {
            const synonymsCount = this.data.nextVarInt();
            const synonyms = new Uint32Array(synonymsCount);
            for (let i = 0; i < synonymsCount; i++) {
                synonyms[i] = this.data.nextVarInt();
            }

            const tailsCount = this.data.nextVarInt();
            const tails = new Uint32Array(tailsCount);
            for (let i = 0; i < tailsCount; i++) {
                const tail = this.data.nextVarInt();
                tails[i] = (tail < synonyms.length ? synonyms[tail] : tail) - synonymsCount;
            }

            const result = new Array(counts.length);
            for (let i = 0; i < counts.length; i++) {
                result[i] = new Array(counts[i]);
            }

            let thisChunk = null;
            let currentTail = 0;
            const tmp = [];
            let t = -1;
            for (let block of result) {
                for (let i = 0; i < block.length; i++, currentTail++) {
                    t++;
                    const tailId = tails[currentTail];
                    if (tailId < this.lz78.length) {
                        const tail = this.lz78[tailId];
                        if (tail.length !== 0 && this.starts.has(tail[0])) {
                            console.log(t, 'only', tailId);
                            block[i] = tail;
                            continue;
                        }
                    }

                    if (thisChunk === null) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        console.log(t, 'chunk', chunkId, addMethodId);
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                    }

                    tmp.length = 0;
                    tmp.push(...thisChunk); // FIXME it is ok to push as is, or even as lz78 index

                    while (true) {
                        const chunkId = this.data.nextVarInt();
                        const prevChunk = this.lz78[(chunkId < synonyms.length ? synonyms[chunkId] : chunkId) - synonymsCount];
                        const addMethodId = this.data.nextVarInt();
                        thisChunk = prevChunk.copyWithNext(addMethodId);
                        this.lz78.push(thisChunk);
                        console.log(t, 'chunk', chunkId, addMethodId);

                        if (this.starts.has(thisChunk[0])) {
                            console.log(t, 'starts', thisChunk[0]);
                            console.log(t, 'ends', tailId);
                            const tail = this.lz78[tailId];
                            tmp.push(...tail);
                            block[i] = new Uint32Array(tmp);
                            break;
                        } else {
                            tmp.push(...thisChunk);
                        }
                    }
                }
            }

            return result;
        }
    }

    class Queue {
        data = new Array(1024);
        first = 0;
        afterLast = 0;

        push(e) {
            let a = this.afterLast;
            let d = this.data;
            d[a++] = e;
            if (a >= this.data.length) {
                a = 0;
            }
            if (a === this.first) {
                let d2 = new Array(d.length * 2);
                let i = 0;
                for (let p = a; p < d.length; p++) {
                    d2[i++] = d[p];
                }
                for (let p = 0; p < a; p++) {
                    d2[i++] = d[p];
                }
                this.data = d2;
                this.first = 0;
                this.afterLast = i;
            } else {
                this.afterLast = a;
            }
        }

        shift() {
            let i = this.first;
            let r = this.data[i++];
            if (i >= this.data.length) {
                this.first = 0;
            } else {
                this.first = i;
            }
            return r;
        }

        size() {
            let r = this.afterLast - this.first;
            if (r < 0) {
                return r + this.data.length;
            }
            return r;
        }

        reset() {
            this.first = this.afterLast = 0;
        }
    }

    function claimHtml(id) {
        let e = document.getElementById(id);
        let r = e.innerHTML;
        e.remove();
        return r;
    }

    let sq = 5;
    let sqPx = sq;
    let sqScale = 1;
    const canvasScrollPadding = 200;
    let canvasTimeHeight = 12;
    let canvasTimeHeightPx = 12;
    let ticksPerSecond = 2592342244;
    let startMs = 1664136399247;

    const zoomToGroupSize = [
        1,              // 20 ms
        50,             // 1 s
        50 * 5,         // 5 s
        50 * 60         // 1 m
    ];
    const zoomToHeight = [50, 60, 60, 60]

    let methods = new DataBuffer(claimHtml("methods"));
    let executionsHeatmap = new HeatmapCollection(claimHtml("executionsHeatmap"));
    let cpool = ["all","","libsystem_pthread.dylib","thread_start","_pthread_start","libjvm.dylib","thread_native_entry","Thread::call_run","JavaThread::run","JavaThread::thread_main_inner","attach_listener_thread_entry","load_agent","JvmtiExport::load_agent_library","libasyncProfiler.so","Agent_OnAttach","Profiler::runInternal","Profiler::start","Profiler::startTimer","jvmti_RunAgentThread","JvmtiEnv::RunAgentThread","AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<548964ull, G1BarrierSet>, ","one.nio.server.AcceptorThread","run","one.nio.net.Socket","acceptNonBlocking","one.nio.net.JavaServerSocket","accept","sun.nio.ch.ServerSocketChannelImpl","implAccept","sun.nio.ch.Net","libsystem_kernel.dylib","CompileBroker::compiler_thread_loop","CompileBroker::invoke_compiler_on_method","C2Compiler::compile_method","Compile::Compile","ParseGenerator::generate","Parse::Parse","Parse::do_all_blocks","Parse::do_one_block","Parse::do_call","PredictedCallGenerator::generate","Parse::do_field_access","Parse::do_get_xxx","GraphKit::access_load_at","BarrierSetC2::load_at","G1BarrierSetC2::load_at_resolved","BarrierSetC2::load_at_resolved","GraphKit::make_load","PhaseGVN::transform_no_reclaim","LoadNode::Ideal","MemNode::Ideal_common","TypePtr::xmeet","TypeInstPtr::xmeet_helper","Type::hashcons","Dict::Insert","Type::cmp","Compile::Optimize","PhaseIdealLoop::optimize","PhaseIdealLoop::build_and_optimize","PhaseIdealLoop::split_if_with_blocks","PhaseIdealLoop::split_if_with_blocks_pre","PhaseIdealLoop::conditional_move","PhaseIdealLoop::is_dominator","PhaseIdealLoop::dom_depth","one.nio.server.SelectorThread","one.nio.net.Session","process","one.nio.http.HttpSession","processRead","processHttpBuffer","handleParsedRequest","one.nio.http.HttpServer","handleRequest","RequestHandler1_entityGet","ok.dht.test.ushkov.RocksDBService","entityGet","ok.dht.test.ushkov.dao.rocksdb.RocksDBDao","get","org.rocksdb.RocksDB","librocksdbjni14282080280465431955.jnilib","Java_org_rocksdb_RocksDB_get__J_3BII","rocksdb_get_helper","rocksdb::CompactedDBImpl::Open","rocksdb::DBImpl::Get","rocksdb::DBImpl::GetImpl","rocksdb::MemTable::Get","rocksdb::SkipListFactory::CreateMemTableRep","Compile::Code_Gen","Matcher::match","Matcher::xform","Arena::contains","rocksdb::Version::Get","rocksdb::TableCache::Get","rocksdb::BlockBasedTable::Get","rocksdb::BlockBasedTableIterator::Prev","rocksdb::Status rocksdb::BlockBasedTable::RetrieveBlock<rocksdb::Block>","rocksdb::NewCompressedSecondaryCache","PhaseChaitin::Register_Allocate","PhaseChaitin::Split","ShouldNotReachHereNode::is_block_proj","PhaseIFG::SquareUp","IndexSetIterator::advance_and_next","PhaseOutput::fill_buffer","IntelJccErratum::compute_padding","PhaseOutput::scratch_emit_size","Label::patch_instructions","rocksdb::DBImpl::DefaultColumnFamily","sendResponse","one.nio.http.Request","getHeader","java.lang.String","regionMatches","java.lang.StringLatin1","regionMatchesCI","os::javaTimeMillis","libsystem_c.dylib","clock_gettime","gettimeofday","CompilationLog::log_compile","CompileTask::print","Method::print_short_name","rocksdb::BlockFetcher::ReadBlockContents","rocksdb::UncompressBlockContents","rocksdb::UncompressBlockContentsForCompressionType","rocksdb::CompressedSecondaryCache::Lookup","snappy::RawUncompress","snappy::Uncompress","void snappy::SnappyDecompressor::DecompressAllTags<snappy::SnappyArrayWriter>","snappy::SnappyArrayWriter::AppendFromSelf","snappy::SnappyIOVecWriter::GetIOVecPointer","one.nio.net.JavaSelector","select","sun.nio.ch.SelectorImpl","lockAndDoSelect","sun.nio.ch.KQueueSelectorImpl","doSelect","sun.nio.ch.KQueue","poll","kevent","snappy::SnappyDecompressor::RefillTag","writeResponse","write","one.nio.net.Session$ArrayQueueItem","one.nio.net.JavaSocket","sun.nio.ch.SocketChannelImpl","sun.nio.ch.IOUtil","writeFromNativeBuffer","sun.nio.ch.SocketDispatcher","sun.nio.ch.FileDispatcherImpl","write0","read","readIntoNativeBuffer","read0","rocksdb::CompactedDBImpl::Get","rocksdb::ColumnFamilyHandleImpl::GetComparator","libc++.1.dylib","std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__assign_external","std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__grow_by_and_replace","libc++abi.dylib","operator new","libsystem_malloc.dylib","_malloc_zone_malloc","szone_malloc_should_clear","tiny_malloc_should_clear","tiny_malloc_from_free_list","rocksdb::RandomAccessFileReader::Read","pread","rocksdb::Block::ApproximateMemoryUsage","rocksdb::IndexBlockIter::SeekImpl","rocksdb::IndexBlockIter::PrefixSeek","rocksdb::GetColumnFamilyUserComparator","jlong_disjoint_arraycopy","rocksdb::Block::NewDataIterator","nanov2_malloc","nanov2_allocate","nanov2_allocate_from_block","Relocation::new_addr_for","free_tiny","get_tiny_previous_free_msize","PhaseCCP::analyze","rocksdb::GetContext::SaveValue","ConnectionGraph::do_analysis","ConnectionGraph::compute_escape","GrowableArrayWithAllocator<Node*, GrowableArray<Node*> >::append","snappy::SnappyArrayWriter::TryFastAppend","snappy::LittleEndian::IsLittleEndian","PhaseCFG::do_global_code_motion","PhaseCFG::global_code_motion","PhaseCFG::schedule_local","rocksdb::MemTable::KeyComparator::operator","rocksdb::Comparator::CreateFromString","PhaseChaitin::post_allocate_copy_removal","PhaseChaitin::elide_copy","PhaseIterGVN::optimize","PhaseIterGVN::transform_old","NodeHash::hash_delete","TypeInstPtr::hash","Compile::call_generator","InlineTree::ok_to_inline","InlineTree::try_to_inline","Matcher::match_tree","Matcher::ReduceInst","rocksdb::BlockBasedTable::DumpDataBlocks","rocksdb::ShardedCache::Insert","rocksdb::NewLRUCache","rocksdb::lru_cache::LRUCacheShard::InsertItem","rocksdb::port::Mutex::Lock","pthread_mutex_lock","free","nanov2_size","rocksdb::cache_entry_roles_detail::RegisteredDeleter<rocksdb::Block, ","free_small","small_free_list_remove_ptr_no_clear","java.nio.ByteBuffer","put","putBuffer","rocksdb::BinarySearchIndexReader::NewIterator","rocksdb::Block::NewIndexIterator","one.nio.http.Response","<init>","rocksdb::RandomAccessFileReader::PrepareIOOptions","toBytes","one.nio.util.ByteArrayBuilder","append","one.nio.util.Utf8","rocksdb::lru_cache::LRUCacheShard::EvictFromLRU","small_malloc_should_clear","small_malloc_from_free_list","small_free_list_remove_ptr","processUpdateQueue","iteratorFor","java.util.HashMap$KeyIterator","next","java.util.HashMap$HashIterator","nextNode","one.nio.server.Server","incRequestsProcessed","java.util.concurrent.atomic.LongAdder","increment","add","java.util.concurrent.atomic.Striped64","casBase","java.lang.invoke.VarHandleGuards","guard_LJJ_Z","java.lang.invoke.VarHandleLongs$FieldInstanceReadWrite","weakCompareAndSetRelease","rocksdb::VerifyBlockChecksum","rocksdb::crc32c::Extend","JavaThread::check_and_handle_async_exceptions","rocksdb::BlockBasedTable::NewRangeTombstoneIterator","nanov2_pointer_size","sun.nio.ch.Util","getTemporaryDirectBuffer","sun.nio.ch.Util$BufferCache","snappy::ByteArraySource::Peek","Java_org_rocksdb_ColumnFamilyHandle_disposeInternal","jni_ExceptionCheck","rocksdb::BlockBasedTable::UpdateCacheMissMetrics","processDeregisterQueue","java.util.ArrayDeque","pollFirst","registerPendingSessions","thread-local wrapper routine for rocksdb::perf_context","rocksdb::ColumnFamilyData::GetThreadLocalSuperVersion","rocksdb::ThreadLocalPtr::Swap","ConcurrentGCThread::run","G1ServiceThread::run_service","G1ServiceThread::run_task","G1RemSetSamplingTask::execute","G1RemSetSamplingTask::sample_young_list_rs_length","G1CollectionSet::iterate","G1YoungRemSetSamplingClosure::do_heap_region","G1CollectionSet::update_young_region_prediction","rocksdb::DataBlockIter::SeekImpl","rocksdb::DataBlockIter::NextImpl","libsystem_platform.dylib","_platform_memmove$VARIANT$Haswell","rocksdb::BlockBasedTable::IndexReaderCommon::GetOrReadIndexBlock","snappy::SnappyDecompressor::ReadUncompressedLength","rocksdb::lru_cache::LRUCacheShard::Lookup","one.nio.net.JavaSelector$1","hasNext","ensureCapacity","jni_SetByteArrayRegion","jni_NewByteArray","TypeArrayKlass::allocate_common","CollectedHeap::array_allocate","MemAllocator::Allocation::check_out_of_memory","rocksdb::ColumnFamilyData::ReturnThreadLocalSuperVersion","rocksdb::ThreadLocalPtr::CompareAndSwap","rocksdb::ThreadLocalPtr::Instance","WatcherThread::run","WatcherThread::sleep","Monitor::wait_without_safepoint_check","os::PlatformMonitor::wait","__psynch_cvwait","rocksdb::DataBlockIter::SeekForGetImpl","_platform_memcmp$VARIANT$Base","operator new[]","rocksdb::ShardedCache::Lookup","MemAllocator::allocate","tiny_free_no_lock","rocksdb::BlockBasedTable::UpdateCacheInsertionMetrics","snappy::SnappyArrayWriter::Produced","_os_semaphore_wait.cold.1","java.nio.MappedByteBuffer","limit","java.nio.Buffer","rocksdb::CachableEntry<rocksdb::Block>::ReleaseCacheHandle","snappy::LittleEndian::Load32","nanov2_free_to_block","Matcher::find_shared","Node::add_req","Node::grow","_platform_bzero$VARIANT$Haswell","tiny_free_list_add_ptr","snappy::Varint::Parse32WithLimit","libdyld.dylib","tlv_get_addr","malloc","rocksdb::Cleanable::~Cleanable","rocksdb::lru_cache::LRUCacheShard::Release","snappy::SnappyArrayWriter::Append","PhaseCFG::schedule_late","Node_Backward_Iterator::next","java.util.concurrent.locks.ReentrantLock","lock","java.util.concurrent.locks.ReentrantLock$Sync","parseRequest","toAsciiString","sun.misc.Unsafe","copyMemory","jdk.internal.misc.Unsafe","copyMemoryChecks","checkPrimitivePointer","checkPrimitiveArray","libnio.dylib","Java_sun_nio_ch_FileDispatcherImpl_write0","fdval","jni_GetByteArrayRegion","check_bounds","ResourceArea::rollback_to","startsWith","rocksdb::ComputeBuiltinChecksum","rocksdb::GetVarint32PtrFallback","rocksdb::ThreadLocalPtr::StaticMeta::Swap","ThreadInVMfromNative::ThreadInVMfromNative","rocksdb::DataBlockIter::SeekForPrevImpl","wrap","java.nio.HeapByteBuffer","rocksdb::Cleanable::Cleanable","small_size","szone_size","tiny_size","java.util.concurrent.ConcurrentLinkedQueue","updateHead","guard_LL_V","java.lang.invoke.VarHandleReferences$FieldInstanceReadWrite","setRelease","advance_directory.cold.1","snappy::SnappyIOVecWriter::TryFastAppend","rocksdb::ReactiveVersionSet::replay_buffer","std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__init_copy_ctor_external","snappy::SnappyArrayWriter::SetExpectedLength","snappy::SnappyArrayWriter::CheckLength","length","Java_org_rocksdb_WriteBatchTest_getContents","Java_sun_nio_ch_SocketDispatcher_read0","small_free_list_add_ptr","rocksdb::Block::~Block","snappy::RawUncompressToIOVec","rocksdb::port::Mutex::Unlock","pthread_mutex_unlock","__commpage_gettimeofday_internal","mach_absolute_time","snappy::ByteArraySource::Skip","unknown_Java","rocksdb::Cleanable::DelegateCleanupsTo","G1ServiceThread::sleep_before_next_cycle","rocksdb::IndexBlockIter::NextImpl","charAt","operator delete","_pthread_cond_wait","szone_malloc","sun.nio.ch.Util$2","clear","java.util.HashSet","java.util.HashMap","rocksdb::GetVarint64Ptr","indexOf","ZBUFFv07_recommendedDOutSize","JNIHandles::make_local","VMThread::run","VMThread::loop","VMThread::wait_for_operation","rocksdb::LookupKey::LookupKey","default_zone_malloc","AccessInternal::PostRuntimeDispatch<G1BarrierSet::AccessBarrier<2646116ull, G1BarrierSet>, ","ok.dht.test.ushkov.dao.BaseEntry","szone_free_definite_size","snappy::ByteArraySource::Available","rocksdb::MemTableListVersion::Get","java.lang.invoke.LambdaForm$MH.0x0000000800c89000","invokeExact_MT","java.lang.invoke.LambdaForm$DMH.0x0000000800c89400","newInvokeSpecial","nanov2_find_block_and_allocate","java.util.concurrent.locks.ReentrantLock$NonfairSync","initialTryLock","java.util.concurrent.locks.AbstractOwnableSynchronizer","setExclusiveOwnerThread","OptoRuntime::new_array_C","_sigtramp","rocksdb::FindFile","rocksdb::IndexValue::DecodeFrom","rocksdb::MemTable::GetMinLogContainingPrepSection","nanov2_free_definite_size","jbyte_disjoint_arraycopy","JNI_OnLoad","JNIHandleBlock::allocate_handle","rocksdb::lru_cache::LRUCache::GetShard","rocksdb::GetContext::GetContext","isAsciiString","convertReturnVal","rocksdb::Hash64","ObjArrayAllocator::initialize","JavaFrameAnchor::make_walkable","__commpage_gettimeofday","thread-local wrapper routine for rocksdb::iostats_context","rocksdb::Block::Block","rocksdb::PosixDirectory::FsyncWithDirOptions","getLong","rocksdb::lru_cache::LRUCache::GetHash","position","std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string","snappy::ByteArraySource::~ByteArraySource","rocksdb::ThreadLocalPtr::StaticMeta::CompareAndSwap","std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::assign","os::javaTimeNanos","__gettimeofday","snappy::SnappyDecompressor::eof","rocksdb::ShardedCache::Release","JvmtiAgentThread::call_start_function","Profiler::timerLoop","snappy::LittleEndian::ToHost32","getRequiredParameter","snappy::internal::WorkingMemory::GetScratchOutput","tiny_free_list_remove_ptr","GangWorker::initialize","GangWorker::loop","G1EvacuateRegionsBaseTask::work","G1EvacuateRegionsBaseTask::evacuate_live_objects","G1ParEvacuateFollowersClosure::do_void","G1ParScanThreadState::steal_and_trim_queue","G1ParScanThreadState::trim_queue_to_threshold","void G1ParScanThreadState::do_oop_evac<narrowOop>","G1ParScanThreadState::do_copy_to_survivor_space","void OopOopIterateBackwardsDispatch<G1ScanEvacuatedObjClosure>::Table::oop_oop_iterate_backwards<InstanceKlass, narrowOop>","G1RemSet::scan_collection_set_regions","G1CollectionSet::iterate_incremental_part_from","G1CollectionSet::iterate_part_from","G1ScanCollectionSetRegionClosure::do_heap_region","G1CodeRootSetTable::nmethods_do","G1CodeBlobClosure::do_code_blob","G1EvacuateRegionsTask::scan_roots","G1RemSet::scan_heap_roots","G1RemSetScanState::iterate_dirty_regions_from","G1ScanHRForRegionClosure::do_heap_region","G1ScanHRForRegionClosure::scan_heap_roots","G1ScanHRForRegionClosure::do_claimed_block","G1ScanHRForRegionClosure::scan_memregion","G1RootProcessor::evacuate_roots","G1RootProcessor::process_java_roots","ClassLoaderDataGraph::roots_cld_do","G1CLDScanClosure::do_cld","ClassLoaderData::ChunkedHandleList::oops_do","void G1ParCopyClosure<","void objArrayOopDesc::oop_iterate_range<G1ScanEvacuatedObjClosure>","void G1ScanEvacuatedObjClosure::do_oop_work<narrowOop>","GenericTaskQueueSet<OverflowTaskQueue<ScannerTask, ","Klass::check_array_allocation_length","java.lang.ThreadLocal","unsafe_arraycopy","rocksdb::Cleanable::RegisterCleanup","oopFactory::new_byteArray","MemAllocator::finish","thread-local wrapper routine for rocksdb::perf_level","getParameter","one.nio.net.Session$QueueItem","MemAllocator::Allocation::notify_allocation","MemAllocator::Allocation::notify_allocation_low_memory_detector","std::__1::moneypunct_byname<wchar_t, true>::moneypunct_byname","rocksdb::EncodeVarint32",];

    let currentHeatmap = executionsHeatmap;
    let currentHeatmapType = 'executions';

    let heatHeight = 60;

    let heatLastSample = -1;
    let heatActiveSample1 = -1;
    let heatActiveSample2 = -1;
    let heatDiffStart = -1;
    let heatDiffEnd = -1;
    let highlightStart = -1;
    let highlightEnd = -1;

    const titleText = document.getElementById("title").textContent;
    document.getElementById("title").style.display = 'none';
    document.title = titleText;

    const heatCanvas = document.getElementById('heatmap-canvas');
    const heatStatus = document.getElementById('status');
    const heatCanvasWrapper = document.getElementById('heatmap-canvas-wrapper');
    const heatCanvasContainer = document.getElementById('heatmap-canvas-container');

    let heatC;
    let prevDx = -1000000000;

    let searchExecutedCount = 0;
    let searchMax = 0;

    const timeOptions = {
        year: '2-digit',
        month: '2-digit',
        day: '2-digit',
        timeZoneName: 'short',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsShort = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 2
    };

    const timeOptionsTiny = {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hourCycle: 'h23',
        //hour12: false
    };

    function methodInfo(methodIndex, out) {
        if (methodIndex === -1) {
            out.className = '';
            out.methodName = 'all';
            out.location = 0;
            out.type = 3;
            return;
        }

        methodIndex--;

        let methodAndClass = methods.int36(methodIndex * 12);
        let locationAndType = methods.int36(methodIndex * 12 + 6)
        let className = (methodAndClass & 0x3FFFF) - 1;
        let methodName = (methodAndClass >>> 18) - 1;

        out.className = cpool[className];
        out.methodName = cpool[methodName];
        out.location = locationAndType >>> 4;
        out.type = locationAndType & 15;
    }

    function title(methodIndex, out) {
        methodInfo(methodIndex, out);
        const codeLine = (out.location & 0xffff);
        let locationSuffix = codeLine === 0 ? "" : (":" + codeLine);

        if (out.methodName === '') {
            return out.className + locationSuffix;
        }
        if (out.className === '') {
            return out.methodName + locationSuffix;
        }
        if (out.type >= 3 && out.type <= 5) {
            return out.methodName + locationSuffix;
        }

        return out.className + "." + out.methodName + locationSuffix;
    }

    let bgInterval = null;
    let bgTasks = [];
    let cooldownTime = 0;
    let nextTask = 0;

    function addTask(id, iteration, afterFrame) {
        for (let t of bgTasks) {
            if (t.id === id) {
                t.f = iteration;
                t.a = afterFrame;
                return;
            }
        }

        bgTasks.push({id: id, f: iteration, a: afterFrame});
        if (bgTasks.length === 1) {
            bgInterval = setInterval(function() {
                let start = performance.now();
                if (start <= cooldownTime) {
                    return;
                }
                let overflow = false;
                do {
                    let task = bgTasks[nextTask];
                    if (task.f()) {
                        nextTask++;
                    } else {
                        bgTasks.splice(nextTask, 1);
                        if (bgTasks.length === 0) {
                            clearInterval(bgInterval);
                            nextTask = 0;
                            return;
                        }
                    }

                    if (nextTask >= bgTasks.length) {
                        nextTask = 0;
                        overflow = true;
                    }
                } while(performance.now() - start < 8);

                for (let q = 0; q < overflow ? bgTasks.length : nextTask; q++) {
                    bgTasks[q].a();
                }
            })
        }
    }

    function prepareFrames(from, to) {
        let mul = zoomToGroupSize[currentHeatmap.zoom];
        from *= mul;
        to = (to + 1) * mul - 1;
        if (to >= currentHeatmap.blocks.length) {
            to = currentHeatmap.blocks.length - 1;
        }

        const frames = new Queue();
        const root = new Map();
        root.c = 0;
        root.m = -1;
        root.x = 0;
        const roots = [root];
        let levelsCount = 1;

        for (let pos = from; pos <= to; pos++) {
            const block = currentHeatmap.blocks[pos];

            root.c += block.length;

            for (let stack of block) {
                levelsCount = Math.max(stack.length + 1, levelsCount);

                frames.push(root);
                frames.push(stack);
            }
        }

        return [frames, roots, levelsCount]
    }

    function nextFrames(frames, level) {
        frames.push(null);  // end stacks marker

        let nowFrame = null;

        while (true) {
            const frame = frames.shift();
            if (frame === null) {   // end stack marker
                break;
            }

            const stack = frames.shift();
            if (level >= stack.length) {
                continue;
            }

            const methodId = stack[level];
            nowFrame = frame.get(methodId);
            if (nowFrame === undefined) {
                nowFrame = new Map();
                nowFrame.m = methodId;
                nowFrame.c = 0;
                frame.set(methodId, nowFrame);
            }
            nowFrame.c++;

            frames.push(nowFrame);
            frames.push(stack);
        }
    }

    function renderTraces(from, to) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }

        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        addTask('flame', function () {
                nextFrames(frames, currentLevel);

                let level = levels[currentLevel];
                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;
                    const t = title(root.m, methodInfoOut);
                    let color = getColor(palette[methodInfoOut.type]);
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [...root.values()];

                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function renderWithMatch(newCanvasHeight, root, level, minLevel) {
        newCanvasHeight = Math.min(32767, newCanvasHeight);
        if (canvasHeight !== newCanvasHeight) {
            canvasHeight = newCanvasHeight;
            canvas.style.height = canvasHeight + 'px';
            canvas.height = canvasHeight * (devicePixelRatio || 1);
            c = canvas.getContext('2d');
            if (devicePixelRatio) c.scale(devicePixelRatio, devicePixelRatio);
            c.font = document.body.style.font;
        }
        const matched = render(root, level, minLevel);
        if (pattern === undefined) {
            document.getElementById('match').style.display = 'none';
            document.getElementById('produced').style.display = 'inherit';
        } else {
            document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
            document.getElementById('match').style.display = 'inline-block';
            document.getElementById('produced').style.display = 'none';
        }
    }

    function renderDiff(from, to, baseFrom, baseTo) {
        let [frames, roots, levelsCount] = prepareFrames(from, to);
        let [baseFrames, baseRoots, ] = prepareFrames(baseFrom, baseTo);
        roots[0].b = baseRoots[0];

        levels.length = 0;
        for (let i = 0; i < levelsCount; i++) {
            levels.push([]);
        }
        let currentLevel = 0;
        let levelToRedraw = 0;
        let methodInfoOut = {};

        let minDiff = 0;
        let maxDiff = 0;

        addTask('flame', function () {
                nextFrames(frames, currentLevel);
                nextFrames(baseFrames, currentLevel);
                let level = levels[currentLevel];

                for (let root of roots) {
                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    if (wasCount !== 0) {
                        maxDiff = Math.max(maxDiff, root.c - wasCount);
                        minDiff = Math.min(minDiff, root.c - wasCount)
                    }
                }

                let nextRoots = [];
                for (let root of roots) {
                    let x = root.x;

                    let wasCount = root.b === undefined ? 0 : root.b.c;
                    const t = title(root.m, methodInfoOut) + " (" + root.c + "/" + wasCount +")";
                    let color;
                    if (wasCount === 0) {
                        color = "#dac571";
                    } else if (wasCount >= root.c) {
                        const ratio = (root.c - wasCount) / minDiff;
                        color = 'rgb(' + (245 - 90 * ratio) + ',' + (250 - 90 * ratio) + ',' + 255 +')';
                    } else {
                        const ratio = (root.c - wasCount) / maxDiff;
                        color = 'rgb(' + 255 + ',' + (245 - 180 * ratio) + ',' + (240 - 200 * ratio) +')';
                    }
                    level.push({left: x, width: root.c, color: color, title: t});

                    let nextFrames = [];
                    for (let [methodId, frame] of root) {
                        frame.b = root.b && root.b.get(methodId);
                        nextFrames.push(frame);
                    }
                    nextFrames.sort((k1, k2) => k2.c - k1.c);
                    for (let frame of nextFrames) {
                        frame.x = x;
                        x += frame.c;
                        nextRoots.push(frame);
                    }
                }
                level.sort((k1, k2) => k1.left - k2.left);

                roots = nextRoots;
                currentLevel++;
                if (currentLevel < levelsCount) {
                    return true;
                }
                renderWithMatch(levelsCount * 16, levels[0][0], 0);
                return false;
            },
            function () {
                renderWithMatch(4096, levels[0][0], 0, levelToRedraw);
                levelToRedraw = currentLevel;
            });
    }

    function redrawHeatSamplesImpl(from, to, dx) {
        const patternDraw = !!pattern;
        const startBlock = currentHeatmap.startBlock();

        const max = currentHeatmap.max();
        const heatmap = currentHeatmap.heatmap();

        for (let index = from; index <= to; index++) {
            let color;
            let i = index - startBlock;
            if (i < 0 || i >= heatmap.length) {
                color = '#ddd';
            } else {
                let count = heatmap[i];

                let useFound = patternDraw && searchExecutedCount > i;
                let maxValue = useFound ? searchMax : max;
                let value = useFound ? found[i] : count;
                let ratio = value / (maxValue || 1);

                if (useFound) {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(' + value + ',' + value + ',255)';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb(0,0,' + value + ')';
                    }
                } else {
                    if (ratio < 0.8) {
                        let value = Math.round(255 - ratio * 255 / 0.8);
                        color = 'rgb(255,' + value + ',' + value + ')';
                    } else {
                        let value = Math.round(255 - (ratio - 0.8) * 100 / 0.2);
                        color = 'rgb('+ value + ',0,0)';
                    }
                }

            }
            heatC.fillStyle = color;

            let x = Math.floor(index / heatHeight);
            let y = index % heatHeight;
            heatC.fillRect(x * sq - dx, y * sq + canvasTimeHeight, sq, sq);
        }

        let blocksBetweenMarks = 20;

        let fromBlock = Math.floor(from / blocksBetweenMarks / heatHeight) - 1;
        let toBlock = Math.ceil(to / blocksBetweenMarks / heatHeight);

        let markPixels = blocksBetweenMarks * sq;

        heatC.fillStyle = '#fff';
        heatC.fillRect(
            fromBlock * markPixels - dx,
            0,
            (toBlock - fromBlock + 1) * markPixels,
            canvasTimeHeight
        );

        heatC.beginPath();
        heatC.moveTo(fromBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.lineTo(toBlock * markPixels - dx + 0.5, canvasTimeHeight + 0.5);
        heatC.stroke();

        heatC.fillStyle = '#000';

        let groupSize = heatHeight;
        let oneBlockMs = currentHeatmap.currentTimeBlock();
        let oneGroupMs = oneBlockMs * groupSize;
        let oneMarkMs = oneGroupMs * blocksBetweenMarks;
        for (let markIndex = fromBlock; markIndex <= toBlock; markIndex++) {
            let origin = Math.floor(startMs / oneMarkMs) * oneMarkMs;
            let ms = origin + markIndex * oneMarkMs;
            let markOffset = markIndex * markPixels - dx;

            let title = new Date(ms).toLocaleTimeString(undefined, timeOptionsTiny);

            let w = heatC.measureText(title).width;
            let x = markOffset + (markPixels - w) / 2;
            heatC.fillText(title, x, canvasTimeHeight - 1, markPixels);

            heatC.beginPath();
            heatC.moveTo(markOffset + 0.5, canvasTimeHeight - 2 * sqScale + 0.5);
            heatC.lineTo(markOffset + 0.5, canvasTimeHeight + 2 * sqScale + 0.5);
            heatC.stroke();
        }
    }

    function redrawHeatSamples(from, to) {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);

        from = Math.max(from, heatHeight * Math.floor(dx / sq));
        to = Math.min(to, heatHeight * Math.ceil((dx + heatCanvas.width) / sq));
        redrawHeatSamplesImpl(from, to, dx);
    }

    function redrawHeatMap() {
        redrawHeatSamples(0, (1 + currentHeatmap.count() / heatHeight | 0) * heatHeight);
    }

    function fillCanvasWithEvents(zoom) {
        searchExecutedCount = 0;
        searchMax = 0;

        addTask('search', function () {
            return false;
        }, function (){});

        currentHeatmap.setZoom(zoom);
        heatHeight = zoomToHeight[zoom];

        const m = devicePixelRatio || 1;
        sqScale = m;
        sqPx = 5;
        sq = Math.floor(sqPx * m);
        sqPx = sq / m;
        canvasTimeHeight = sq * 2 + 2;
        canvasTimeHeightPx = canvasTimeHeight / m;

        const widthPx = canvasScrollPadding + heatCanvasContainer.offsetWidth + canvasScrollPadding;
        const heightPx = sqPx * heatHeight + canvasTimeHeightPx;

        const heatWidthPx = Math.max(20, Math.ceil(currentHeatmap.count() / heatHeight)) * sqPx;
        heatCanvasWrapper.style.width = heatWidthPx + 'px';
        if (heatCanvasContainer.offsetWidth > heatWidthPx) {
            heatCanvasContainer.style.overflowX = 'hidden';
        } else {
            heatCanvasContainer.style.overflowX = 'scroll';
        }

        heatCanvas.width = Math.ceil(widthPx * m);
        heatCanvas.height = Math.ceil(heightPx * m);
        heatCanvas.style.width = widthPx + 'px';
        heatCanvas.style.height = heightPx + 'px';

        heatC = heatCanvas.getContext('2d');
        heatC.font = sq * 2 + 'px Verdana, sans-serif';
        heatC.lineWidth = 1;
        heatC.strokeStyle = '#000';

        document.getElementById('heatmap-height-line').textContent = [' 1 sec : 20 ms ',' 1 min : 1 sec ',' 5 min : 5 sec ',' 1 hr  : 1 min '][currentHeatmap.zoom];
        redrawHeatMap();
    }

    let found = new Uint32Array(0);

    function searchIterative(r) {
        if (r && (r = prompt('Enter regexp to search:', '')) === null) {
            return;
        }
        searchExecutedCount = 0;
        searchMax = 0;
        if (!r) {
            pattern = undefined;
            redrawHeatMap();
            addTask('search', function () {
                return false;
            }, function (){});
            return;
        }
        let renderFrom = 0;
        let heatmap = currentHeatmap.heatmap();
        let count = heatmap.length;
        found = new Uint32Array(count);
        let start = currentHeatmap.startBlock();
        function renderFunc() {
            redrawHeatSamples(start + renderFrom, start + searchExecutedCount - 1);
            renderFrom = searchExecutedCount;
        }
        pattern = r ? RegExp(r) : undefined;
        const matchedMethods = new Set();
        const methodOut = {};
        for (let index = methods.data.length / 12; index >= 0; index--) {
            if (pattern.test(title(index, methodOut))) {
                matchedMethods.add(index);
            }
        }

        let mul = zoomToGroupSize[currentHeatmap.zoom];

        addTask('search', function () {
            let amount = 0;
            const from = searchExecutedCount * mul;
            const to = (searchExecutedCount + 1) * mul;
            for (let i = from; i < to; i++) {
                const stacks = currentHeatmap.blocks[i];
                if (stacks === undefined) {
                    continue;
                }

                for (let stack of stacks) {
                    for (let methodIndex of stack) {
                        if (matchedMethods.has(methodIndex)) {
                            amount++;
                            break;
                        }
                    }
                }
            }

            if (searchMax < amount) {
                renderFrom = 0;
                searchMax = amount;
            }

            found[searchExecutedCount] = amount;
            searchExecutedCount++;
            if (searchExecutedCount >= count) {
                renderFunc();

                const matched = render(root, rootLevel);
                document.getElementById('matchval').textContent = pct(matched, root.width) + '%';
                document.getElementById('match').style.display = r ? 'inherit' : 'none';
                document.getElementById('produced').style.display = r ? 'none' : 'inherit';

                return false;
            }
            return true;
        }, renderFunc);

    }

    function renderHeatmap() {
        let dx = heatCanvasContainer.scrollLeft - canvasScrollPadding;
        heatCanvas.style.transform = 'translate(' + dx + 'px, 0px)';

        const width = Math.floor(heatCanvasContainer.offsetWidth / sq / (devicePixelRatio || 1));

        let z = 0;
        for (; z < zoomToGroupSize.length; z++) {
            if (currentHeatmap.blocks.length / (zoomToGroupSize[z] * zoomToHeight[z]) < width) {
                break;
            }
        }

        fillCanvasWithEvents(Math.min(z, currentHeatmap.maxZoom - 1));

        renderTraces(0, currentHeatmap.heatmap().length - 1);
    }

    heatCanvasContainer.addEventListener('scroll', function() {
        let dx = Math.floor((heatCanvasContainer.scrollLeft - canvasScrollPadding) * sqScale);
        let dxPx = dx / sqScale;
        heatCanvas.style.transform = 'translate(' + dxPx + 'px, 0px)';
        let delta = Math.abs(dx - prevDx);
        if (delta >= heatCanvas.width || searchExecutedCount !== 0) {
            redrawHeatMap();
        } else {
            heatC.drawImage(heatCanvas, prevDx - dx, 0);
            if (prevDx < dx) {
                let from = heatHeight * Math.floor((prevDx + heatCanvas.width) / sq);
                let to = heatHeight * Math.ceil((dx + heatCanvas.width) / sq);
                redrawHeatSamplesImpl(from, to, dx);
            } else {
                let from = heatHeight * Math.floor(dx / sq);
                let to = heatHeight * Math.ceil(prevDx / sq);
                redrawHeatSamplesImpl(from, to, dx);
            }
        }
        prevDx = dx;
        cooldownTime = performance.now() + 500;
    });

    document.getElementById('heatmap-height-line').onclick = function() {
        fillCanvasWithEvents((currentHeatmap.maxZoom + currentHeatmap.zoom - 1) % (currentHeatmap.maxZoom));
        highlightStart = highlightEnd = heatDiffStart = heatDiffEnd = heatActiveSample1 = heatActiveSample2 = -1;
        for (let suffix of ['Selection', 'Diff', 'Active']) {
            for (let prefix of ['left', 'leftMiddle', 'middle', 'rightMiddle', 'right']) {
                document.getElementById(prefix + suffix).style.display = 'none';
            }
        }
    }

    function callHighlightRedraw(start, end, suffix) {
        let left = document.getElementById('left' + suffix);
        let leftMiddle = document.getElementById('leftMiddle' + suffix);
        let middle = document.getElementById('middle' + suffix);
        let rightMiddle = document.getElementById('rightMiddle' + suffix);
        let right = document.getElementById('right' + suffix);

        let x1 = Math.floor(start / heatHeight);
        let y1 = start % heatHeight;
        let x2 = Math.floor(end / heatHeight);
        let y2 = end % heatHeight;

        let veryStartX = x1 * sqPx;
        let veryStartY = y1 * sqPx;
        let veryEndX = x2 * sqPx;
        let px = 1 / sqScale;
        let singleElementWidth = sqPx + px;

        let topPadding = canvasTimeHeightPx;

        if (x1 === x2) {
            left.style.display = 'none';
            right.style.display = 'none';

            for (let b of [middle, leftMiddle, rightMiddle]) {
                b.style.left = veryStartX + 'px';
                b.style.top = topPadding + veryStartY + 'px';
                b.style.width = singleElementWidth + 'px';
                b.style.height = (y2 - y1 + 1) * sqPx + px + 'px';
                b.style.display = 'block';
            }
        } else {
            left.style.left = veryStartX + 'px';
            left.style.top = topPadding + veryStartY + 'px';
            left.style.width = singleElementWidth + 'px';
            left.style.height = (heatHeight - y1) * sqPx + px + 'px';
            left.style.display = 'block';

            leftMiddle.style.left = veryStartX + 'px';
            leftMiddle.style.top = topPadding + 'px';
            leftMiddle.style.width = singleElementWidth + 'px';
            leftMiddle.style.height = y1 * sqPx + px + 'px';
            leftMiddle.style.display = 'block';

            rightMiddle.style.left = veryEndX + 'px';
            rightMiddle.style.top = topPadding + (y2 + 1) * sqPx + 'px';
            rightMiddle.style.width = sqPx + px + 'px';
            rightMiddle.style.height = (heatHeight - y2 - 1) * sqPx + px + 'px';
            rightMiddle.style.display = 'block';

            right.style.left = veryEndX + 'px';
            right.style.top = topPadding + 'px';
            right.style.width = sqPx + px + 'px';
            right.style.height = (y2 + 1) * sqPx + px + 'px';
            right.style.display = 'block';

            if (x2 - x1 === 1) {
                middle.style.display = 'none';
            } else {
                middle.style.left = veryStartX + sqPx + px + 'px';
                middle.style.top = topPadding + 'px';
                middle.style.width = (x2 - x1 - 1) * sqPx - px + 'px';
                middle.style.height = heatHeight * sqPx + px + 'px';
                middle.style.display = 'block';
            }
        }
    }

    function callSelectionRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            highlightStart = sample;
            highlightEnd = sample + Math.abs(heatActiveSample1 - heatActiveSample2);
        } else if (shiftPressed && heatActiveSample1 !== -1) {
            highlightStart = Math.min(heatActiveSample1, sample);
            highlightEnd = Math.max(heatActiveSample1, sample);
        } else {
            highlightStart = highlightEnd = sample;
        }

        callHighlightRedraw(highlightStart, highlightEnd, 'Selection');

        const index = sample - currentHeatmap.startBlock();
        const heatmap = currentHeatmap.heatmap();
        if (index >= 0 && index < heatmap.length) {
            const ms = startMs + currentHeatmap.currentTimeBlock() * index;
            const total =  heatmap[index];
            const max = currentHeatmap.max();
            heatCanvas.title = new Date(ms).toLocaleTimeString(undefined, timeOptionsShort) + " " + index;  // FIXME
            const totalText = "total: " + total + " (" + Math.floor(total / max * 100) + "%)";
            const searchText = searchExecutedCount > index
                ? "; match: " + found[index] + " (" + Math.floor(found[index] / Math.max(total, 1) * 100) + "%)"
                : "";
            status.textContent = totalText + searchText;
            status.style.display = 'inline';
        } else {
            status.style.display = 'none';
        }
    }

    function callActiveRedraw(sample, shiftPressed, ctrlPressed) {
        if (ctrlPressed) {
            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            heatDiffStart = highlightStart;
            heatDiffEnd = highlightEnd;

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            renderDiff(
                minSelected - currentHeatmap.startBlock(),
                maxSelected - currentHeatmap.startBlock(),
                heatDiffStart - currentHeatmap.startBlock(),
                heatDiffEnd - currentHeatmap.startBlock()
            );
        } else {
            heatDiffStart = -1;
            heatDiffEnd = -1;
            if (shiftPressed && heatActiveSample1 !== -1) {
                heatActiveSample2 = sample;
            } else {
                heatActiveSample1 = heatActiveSample2 = sample;
            }

            let minSelected = Math.min(heatActiveSample1, heatActiveSample2);
            let maxSelected = Math.max(heatActiveSample1, heatActiveSample2);

            callHighlightRedraw(highlightStart, highlightEnd, 'Diff');
            callHighlightRedraw(minSelected, maxSelected, 'Active');
            renderTraces(
                Math.max(0, minSelected - currentHeatmap.startBlock()),
                Math.min(currentHeatmap.heatmap().length - 1, maxSelected - currentHeatmap.startBlock())
            );
        }
    }

    window.addEventListener('keydown', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, true, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, true);
        }
    });

    window.addEventListener('keyup', function (e) {
        if (e.key === 'Shift') {
            callSelectionRedraw(heatLastSample, false, e.ctrlKey);
        } else if (e.key === 'Control') {
            callSelectionRedraw(heatLastSample, e.shiftKey, false);
        }
    });

    heatCanvas.onmousemove = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        if (y >= heatHeight) {
            y = heatHeight - 1;
        }
        heatLastSample = x * heatHeight + y;
        if ((event.buttons & 1) === 1) {
            callSelectionRedraw(heatLastSample, true, event.ctrlKey);
        } else {
            callSelectionRedraw(heatLastSample, event.shiftKey, event.ctrlKey);
        }
    }

    heatCanvas.onmouseout = function () {
        status.style.display = 'none';
    };

    heatCanvas.onmousedown = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, event.shiftKey, event.ctrlKey);
    };

    heatCanvas.onmouseup = function (event) {
        let x = Math.floor((event.offsetX + heatCanvasContainer.scrollLeft - canvasScrollPadding) / sqPx);
        let y = Math.floor(Math.max(0, event.offsetY - canvasTimeHeightPx) / sqPx);
        let sample = x * heatHeight + y;

        callActiveRedraw(sample, true, event.ctrlKey);
    };



init();
// FIXME search(/*highlight:*/);
</script></body></html>
